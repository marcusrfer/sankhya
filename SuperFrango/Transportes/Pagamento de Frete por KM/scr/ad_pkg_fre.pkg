create or replace package ad_pkg_fre is

  soma_pedagio constant varchar2(1) := get_tsipar_logico('SOMAPEDAGIOFRET');

  type num_requests is table of number;

  --M. Rangel, funcção que retorna uma strig contendo as regiões de frete da OC
  function get_regioes_oc(p_codemp number,
                          p_oc     number) return varchar2;

  /*
  * Autor: Marcus Rangel
  * Objetivo: Retorna a distância entre duas cidades
  * utilizando o cadastro de distância.
  */
  function distancia_entre_cidades_oc(p_codemp     number,
                                      p_ordemcarga int) return float;
  function distancia_entre_parceiros(p_codparcorig number,
                                     p_codparcdest number) return float;

  /*
  * Autor: Marcus Rangel
  * Objetivo: Calcula a distância geodesica entre dois pontos
  */
  function distancia_cartesiana(p_lat_ini varchar2,
                                p_lon_ini varchar2,
                                p_lat_fin varchar2,
                                p_lon_fin varchar2) return number;

  -- verifica se ordem de carga informada é carona, retorna true ou false
  function check_carona(p_codemp     number,
                        p_ordemcarga number) return boolean;

  /*
  * Autor: Marcus Rangel
  * Objetivo: Função que retornar a distância total entre todos os
  * pontos em uma ordem de carga.
  */
  function get_distancia_total_oc(p_codemp     number,
                                  p_ordemcarga number) return float;

  /*
  * Autor: Marcus Rangel
  * Objetivo: Função que retorna o valor da ordem de carga, baseando-se
  * nos parametros definidos da tela de regiões de frete e praças de 
  * pedágio
  */
  function get_valor_oc_regfrete(p_codemp     number,
                                 p_ordemcarga number) return float;

  /*
  * Autor: Marcus Rangel
  * Objetivo: Método que busca a latitude e a longitude do parceiro
  * no google maps, similar ao botão mapas no cadastro de parceiro, 
  * porém, pode ser usado para operações em lote.
  */
  procedure atualiza_coord_parc(p_codparc number,
                                p_coord   out varchar2,
                                p_link    out varchar2,
                                p_errmsg  out varchar2);

  /* 
  * Autor: Marcus Rangel
  * Objetivo: Procedure chamada pela procedure do botão de ação,
  * a mesma executa a busca da distância e grava na tabela AD_TSFRFV
  */
  procedure set_distancia_rota(p_codemp     number,
                               p_ordemcarga number);

  /* 
  * Autor: Marcus Rangel
  * Objetivo: Procedure chamada pela procedure do botão de ação,
  * a mesma executa a busca do valor e grava na tabela  AD_TSFRFV
  */
  procedure set_valor_rota(p_codemp     number,
                           p_ordemcarga number);

  /* Autor: M.Rangel
  * Objetivo: Procedure que atualiza a distância e o valor do frete da ordem de carga considerando as regras para carona, definidas no cadastro de regiões de 
              frete, aba "caronas"
  */
  procedure set_dist_vlr_carona(p_codemp     number,
                                p_ordemcarga number,
                                p_distrota   float);

  --Autor: Marcus Rangel
  --Objetivo: Buscar a distância no google maps a distância de dois pontos.

  function get_distancia_xml(v_coord_orig varchar2,
                             v_coord_dest varchar2) return float;

  --Autor: Marcus Rangel
  --Objetivo: Determinar a sequencia de entrega da ordem de carga pela distância entre os parceiros.

  procedure set_sequencia_rota(p_codemp     number,
                               p_ordemcarga number,
                               p_errmsg     out varchar2);

  /* M. Rangel - Busca o valor do km pela região e categoria */
  function get_vlr_regfrete(p_codregfre number,
                            p_codcat    number,
                            p_distancia float) return float;

  /* M.Rangel - Calcula o valor do pedágio pela ordem de carga, compõe o valor do frete */
  function get_vlr_pedagio(p_codemp     number,
                           p_ordemcarga number,
                           p_codcat     number) return float;

  -- Autor: M. Rangel
  -- Objetivo: Buscar o cód. região de frete do parceiro percorrendo a hierarquia do cadastro de regiões 
  function get_codregfrete(p_codparc number) return number;

  function ocevento(p_codveiculo number,
                    p_codevento  number) return float;

  function get_vlrfrete_formula(p_nunota     number,
                                p_codemp     number,
                                p_codparc    number,
                                p_ordemcarga number,
                                p_codveiculo number) return float;

  procedure set_vlrfrete_formula(p_nunota     number,
                                 p_codemp     number,
                                 p_codparc    number,
                                 p_ordemcarga number,
                                 p_codveiculo number,
                                 p_errmsg     out varchar2);

  -- calculo do valor da rota usando os valores de distância  do HBSIS
  procedure set_valor_rota_hbsis(p_dtini date,
                                 p_dtfin date);

end ad_pkg_fre;
/
create or replace package body ad_pkg_fre is

  -- busca a distancia informada no cadastro das cidades
  function distancia_entre_cidades_oc(p_codemp     number,
                                      p_ordemcarga int) return float is
    cidade_emp  int;
    cidade_orig int;
    cidade_dest int;
    distancia   float := 0;
  begin
  
    select e.codcid into cidade_emp from tsiemp e where e.codemp = p_codemp;
  
    cidade_orig := cidade_emp;
  
    for c_dist in (select c.seqcarga, p.codcid
                     from tgfcab c
                     join tgfpar p
                       on c.codparc = p.codparc
                    where c.codemp = p_codemp
                      and c.ordemcarga = p_ordemcarga
                    order by c.seqcarga)
    loop
      cidade_dest := c_dist.codcid;
    
      if cidade_orig = cidade_dest then
        distancia := distancia + 0;
      else
        distancia := distancia + ad_get.distanciacidade(cidade_orig, cidade_dest);
      end if;
    
      cidade_orig := c_dist.codcid;
      --Dbms_Output.put_line(distancia);
    end loop;
  
    distancia := distancia + ad_get.distanciacidade(cidade_emp, cidade_dest);
  
    return distancia;
  
  exception
    when others then
      return 0;
  end distancia_entre_cidades_oc;

  -- busca a distancia cadastrada entre parceiros
  function distancia_entre_parceiros(p_codparcorig number,
                                     p_codparcdest number) return float is
    v_distancia float;
  begin
    begin
      select d.distancia
        into v_distancia
        from tsidis d
       where d.codparcorig = p_codparcorig
         and d.codparcdest = p_codparcdest;
    exception
      when others then
        v_distancia := 0;
    end;
    return v_distancia;
  end;

  -- busca a distancia utilizando fórmula cartesiana
  function distancia_cartesiana(p_lat_ini varchar2,
                                p_lon_ini varchar2,
                                p_lat_fin varchar2,
                                p_lon_fin varchar2) return number is
    v_rad       number := 8200; -- := 8200; --6387.7; raio equatorial 6378.13, raio polar 6357
    v_grausrad  number := 57.30; --57.29577951; -- 1 radiano possui 57,30 mts
    lat1        number;
    lon1        number;
    lat2        number;
    lon2        number;
    v_distancia number;
  begin
  
    lat1 := to_number(replace(p_lat_ini, '.', ','));
    lon1 := to_number(replace(p_lon_ini, '.', ','));
    lat2 := to_number(replace(p_lat_fin, '.', ','));
    lon2 := to_number(replace(p_lon_fin, '.', ','));
  
    v_distancia := round((nvl(v_rad, 0) *
                         acos((sin(nvl(lat1, 0) / v_grausrad) * sin(nvl(lat2, 0) / v_grausrad)) +
                               (cos(nvl(lat1, 0) / v_grausrad) * cos(nvl(lat2, 0) / v_grausrad) *
                               cos(nvl(lon2, 0) / v_grausrad - nvl(lon1, 0) / v_grausrad)))));
  
    return v_distancia;
  
  end distancia_cartesiana;

  /* Verifica se a ordem de carga é carona de acordo com regra definida, 2 OC no mesmo caminhão */
  function check_carona(p_codemp     number,
                        p_ordemcarga number) return boolean is
    veiculo number;
    data    date;
    carona  varchar2(1);
    i       int;
  begin
  
    begin
      select o.codveiculo, o.dtinic, nvl(o.ad_carona, 'N')
        into veiculo, data, carona
        from tgford o
       where o.codemp = p_codemp
         and o.ordemcarga = p_ordemcarga
         and o.temtransbordo = 'N';
    exception
      when others then
        return false;
    end;
  
    if carona = 'S' then
      return true;
    else
    
      select count(*)
        into i
        from (select o.ordemcarga
                 from tgford o
                where codveiculo = veiculo
                  and dtinic = data
                  and codemp != p_codemp
                  and ordemcarga != p_ordemcarga
                  and o.temtransbordo = 'S'
               union
               select o.ordemcarga
                 from tgford o
                where codveiculo = veiculo
                  and dtinic = data
                  and codemp != p_codemp
                  and ordemcarga != p_ordemcarga
                  and o.ordemcargapai > 0
                  and o.ordemcargapai <> o.ordemcarga
                  and o.ordemcargapai <> p_ordemcarga);
    end if;
  
    if i > 0 then
      return true;
    else
      return false;
    end if;
  
  end check_carona;

  /* verifica se a modalidade de pagamento é "frete por peso", modalidade que considera
  o peso da carona sobre peso total da carga para definir o valor a ser pago */
  function check_fretepeso(p_codemp     number,
                           p_ordemcarga number) return varchar2 is
    ord tgford%rowtype;
    i   int;
    x   int;
  begin
  
    begin
      select *
        into ord
        from tgford o
       where o.codemp = p_codemp
         and o.ordemcarga = p_ordemcarga;
    exception
      when no_data_found then
        return 'N';
    end;
  
    select count(*)
      into i
      from tgford o
     where o.codveiculo = ord.codveiculo
       and o.dtinic = ord.dtinic
       and o.codemp != ord.codemp
       and o.ordemcarga != ord.ordemcarga
       and o.temtransbordo = 'N';
  
    if i > 0 then
      select count(*)
        into x
        from tgford o
       where o.ordemcarga = ord.ordemcargapai
         and o.temtransbordo = 'S';
    end if;
  
    if x > 0 then
      dbms_output.put_line('frete por peso ');
      return 'S';
    else
      return 'N';
    end if;
  
  end check_fretepeso;

  -- Objetivo: Buscar o cód. região de frete do parceiro percorrendo a hierarquia do cadastro de regiões 
  function get_codregfrete(p_codparc number) return number is
    v_codreg    number;
    v_codregfre number;
    sql_stmt    varchar2(4000);
    pivot_stmt  varchar2(4000);
  
    c_cur sys_refcursor;
    c     number;
  
  begin
  
    begin
      select codreg into v_codreg from tgfpar p where p.codparc = p_codparc;
    exception
      when no_data_found then
        return 0;
    end;
  
    begin
      select substr(sys_connect_by_path('' || codreg || '', ','), 2,
                     length(sys_connect_by_path('' || codreg || '', ',')))
        into pivot_stmt
        from tsireg
       where codreg = v_codreg
         and rownum = 1
      connect by prior codreg = codregpai
       start with codreg > 0;
    exception
      when others then
        return 0;
    end;
  
    --Dbms_Output.Put_Line(pivot_stmt);
  
    sql_stmt := 'Select codreg from tsireg where codreg in (' || pivot_stmt || ') order by 1 desc';
  
    --Dbms_Output.Put_Line(sql_stmt);
  
    open c_cur for sql_stmt;
    loop
      exit when c_cur%notfound;
      fetch c_cur
        into c;
      if v_codregfre is null then
        select ad_codregfre into v_codregfre from tsireg where codreg = c;
      else
        exit;
      end if;
    end loop;
    close c_cur;
    --Dbms_Output.Put_Line('Região de Frete: ' || v_codregfre);
  
    return v_codregfre;
  
  exception
    when others then
      return 0;
  end get_codregfrete;

  /* Busca a distância total da ordem de carga */
  function get_distancia_total_oc(p_codemp     number,
                                  p_ordemcarga number) return float is
    ponto_inicial varchar2(50);
    ponto_final   varchar2(50);
    v_coord_orig  varchar2(50);
    v_coord_dest  varchar2(50);
    v_codparc     number;
    v_km          float;
    km_total      float := 0;
    qtd_req       number := 0;
  begin
  
    /* Busca a localização do parceiro de origem da ordem de carga */
    begin
      select replace(p.latitude, ',', '.') || '%2C' || replace(p.longitude, ',', '.')
        into ponto_inicial
        from tgfpar p
        join tgford o
          on p.codparc = o.codparcorig
         and o.codemp = p_codemp
         and o.ordemcarga = p_ordemcarga
       where p.latitude is not null
         and p.longitude is not null;
    exception
      when no_data_found then
        raise;
    end;
  
    --percorre os parceiros da ordem de carga
    for parc in (select codparc, min(sequencia) sequencia, coordenada
                   from (select p.codparc, 1 sequencia,
                                 substr(replace(p.latitude, ',', '.'), 1, 9) || '%2C' ||
                                  substr(replace(p.longitude, ',', '.'), 1, 9) coordenada
                            from tgfpar p
                            join tgford o
                              on p.codparc = o.codparcorig
                             and o.codemp = p_codemp
                             and o.ordemcarga = p_ordemcarga
                           where p.latitude is not null
                             and p.longitude is not null
                          union
                          select p.codparc, c.seqcarga sequencia,
                                 substr(replace(p.latitude, ',', '.'), 1, 9) || '%2C' ||
                                  substr(replace(p.longitude, ',', '.'), 1, 9)
                            from tgfpar p, tgfcab c
                           where c.codparc = p.codparc
                             and c.codemp = p_codemp
                             and c.ordemcarga = p_ordemcarga
                             and p.latitude is not null
                             and p.longitude is not null)
                  group by codparc, coordenada
                  order by sequencia)
    loop
    
      v_codparc := parc.codparc;
    
      if v_coord_orig is null then
        v_coord_orig := parc.coordenada;
      else
      
        if v_coord_dest is not null then
          v_coord_orig := v_coord_dest;
        end if;
      
      end if;
    
      if parc.sequencia > 1 then
      
        if parc.coordenada is null then
          continue;
        end if;
      
        v_coord_dest := parc.coordenada;
      
        v_km := get_distancia_xml(v_coord_orig, v_coord_dest);
      
        /*Dbms_Output.put_line(v_Coord_Orig || ' / ' || v_Coord_Dest || ' - ' || v_km);*/
      
        km_total := km_total + v_km;
      
        ponto_final := v_coord_dest;
      
      end if;
    
      qtd_req := qtd_req + 1;
    
    end loop parc;
  
    -- calcula a volta
    if ponto_final is not null then
    
      -- Para utilizar a mesma distância simulando ida direta,
      -- Para obter o mesmo valor do gmaps, inverter o ponto inicial/final
      v_km := get_distancia_xml(ponto_inicial, ponto_final);
    
      /*Dbms_Output.put_line(ponto_inicial || ' / ' || ponto_final || ' - ' || v_km);*/
    
      km_total := km_total + v_km;
    end if;
  
    /*
    Dbms_Output.put_line('KM Total: ' || km_total);
    qtd_req := qtd_req + 1;
    Dbms_Output.put_line(qtd_req);
    */
  
    return km_total;
  
  exception
    when others then
      raise;
  end get_distancia_total_oc;

  /* 
  * Autor: Marcus Rangel
  * Objetivo: Procedure chamada pela procedure AD_STP_FRE_CALCVLROC_SF do botão de ação "Calcular Valores de Frete da OC",
  * a mesma executa a busca da distância e grava na tabela  AD_TSFRFV
  */
  procedure set_distancia_rota(p_codemp     number,
                               p_ordemcarga number) is
    v_distancia float;
    i           int := 0;
  begin
  
    select count(*)
      into i
      from ad_tsfrfv v
     where v.codemp = p_codemp
       and v.ordemcarga = p_ordemcarga;
  
    -- busca a distância total da rota
    --v_distancia := get_distancia_total_oc(p_codemp, p_ordemcarga);
    begin
      select ad_kmrota
        into v_distancia
        from tgford
       where codemp = p_codemp
         and ordemcarga = p_ordemcarga;
    exception
      when no_data_found then
        v_distancia := 0;
    end;
  
    -- merge
    if i = 0 then
      insert into ad_tsfrfv values (p_codemp, p_ordemcarga, v_distancia, 0);
    else
      update ad_tsfrfv
         set distrota = v_distancia
       where codemp = p_codemp
         and ordemcarga = p_ordemcarga;
    end if;
  
  end set_distancia_rota;

  function get_vlr_regfrete(p_codregfre number,
                            p_codcat    number,
                            p_distancia float) return float is
    v_vlrkm float;
  begin
    for r in (select c.codregfre, c.descrregfre, r.codcat, r.dtvigor, r.vlrsaida, i.vlrkm, i.vlrfixo
                from ad_tsfrfc c
                left join ad_tsfrfr r
                  on c.codregfre = r.codregfre
                left join ad_tsfrfi i
                  on i.nurfr = r.nurfr
                 and i.codregfre = r.codregfre
               where c.codregfre = p_codregfre
                 and p_distancia between i.inicioint and i.finalint
                 and r.codcat = p_codcat
                 and r.dtvigor = (select max(dtvigor)
                                    from ad_tsfrfr r2
                                   where r2.codregfre = r.codregfre
                                     and r2.codcat = r.codcat
                                     and r2.dtvigor <= sysdate))
    loop
    
      if r.vlrfixo = 'S' then
        v_vlrkm := nvl(r.vlrsaida, 0) + r.vlrkm;
      else
        v_vlrkm := nvl(r.vlrsaida, 0) + (r.vlrkm * p_distancia);
      end if;
    
    end loop;
  
    return nvl(v_vlrkm, 0);
  
  end get_vlr_regfrete;

  function get_vlr_pedagio(p_codemp     number,
                           p_ordemcarga number,
                           p_codcat     number) return float is
    v_vlrpedagio float;
  begin
    select nvl(cat.vlrpedagio, 0) * c.qtdeixos
      into v_vlrpedagio
      from ad_tsfrfpcat cat
      join ad_tsfcat c
        on c.codcat = cat.codcat
      join ad_tsfrfpcid cid
        on cid.codpraca = cat.codpraca
      join ad_tsfrfp p
        on p.codpraca = cat.codpraca
     where nvl(p.ativo, 'N') = 'S'
       and cat.codcat = p_codcat
       and cat.dtvigor = (select max(c2.dtvigor)
                            from ad_tsfrfpcat c2
                           where c2.codpraca = cat.codpraca
                             and c2.codcat = cat.codcat
                             and c2.dtvigor <= sysdate)
       and exists (select 1
              from tgfpar par, tgfcab cab
             where par.codparc = cab.codparc
               and cab.codemp = p_codemp
               and cab.ordemcarga = p_ordemcarga
               and par.codcid = cid.codcid);
  
    return v_vlrpedagio;
  
  exception
    when others then
      return 0;
  end get_vlr_pedagio;

  --M. Rangel
  /* Função que retorna o valor do frete de uma ordem de carga  */
  function get_valor_oc_regfrete(p_codemp     number,
                                 p_ordemcarga number) return float is
    v_codveiculo number;
    v_distrota   float;
    v_codcat     number;
    valor_atual  float := 0;
    valor_final  float := 0;
    qtd_eixos    number;
    vlr_pedagio  float := 0;
    errmsg       varchar2(4000);
    error exception;
  
  begin
    /*
    * Autor: Marcus Rangel
    * Objetivo: Função que retorna o valor da ordem de carga, baseando-se
    * nos parametros definidos da tela de regiões de frete e praças de 
    * pedágio
    */
  
    --Busca os dados do veículo da ordem de carga
    begin
      select o.codveiculo, v.ad_codcat, nvl(v.ad_qtdeixos, 0), o.ad_kmrota
        into v_codveiculo, v_codcat, qtd_eixos, v_distrota
        from tgford o
        join tgfvei v
          on o.codveiculo = v.codveiculo
       where o.codemp = p_codemp
         and o.ordemcarga = p_ordemcarga;
    
      if v_codcat is null or qtd_eixos is null then
        errmsg := 'Não encontramos a categoria ou a quantidade de eixos do veículo ' ||
                  v_codveiculo;
        raise error;
      end if;
    
      dbms_output.put_line('Veículo: ' || v_codveiculo || ', Cat: ' || v_codcat || ', Eixos: ' ||
                           qtd_eixos);
    
    end;
  
    -- percorre as regiões da ordem de carga
    /*For C_reg In (Select Distinct P.Ad_codregfre Codregfre
     From Tgfpar P
     Join Tgfcab C
       On C.Codparc = P.Codparc
    Where C.Codemp = p_codemp
      And C.Ordemcarga = p_ordemcarga)*/
  
    for c_reg in (select p.codregfre
                    from ad_tsfrocc c
                    join ad_tsfrocp p
                      on c.numrocc = p.numrocp
                   where c.codemp = p_codemp
                     and c.ordemcarga = p_ordemcarga
                   group by p.codregfre)
    loop
      dbms_output.put_line('Regiao de Frete: ' || c_reg.codregfre);
    
      /*Busca a distância da rota pela localização dos parceiros*/
    
      /* begin
        select v.distrota
          into v_distrota
          from ad_tsfrfv v
         where v.codemp = p_codemp
           and v.ordemcarga = p_ordemcarga;
       exception
        when no_data_found then
         v_distrota := get_distancia_total_oc(p_codemp, p_ordemcarga);
       end;
      */
      -- preço da região
      begin
        valor_atual := get_vlr_regfrete(c_reg.codregfre, v_codcat, v_distrota);
      end;
    
    end loop c_reg;
  
    if soma_pedagio = 'S' then
      /*Busca o valor do pedágio por cidade / categoria*/
      vlr_pedagio := get_vlr_pedagio(p_codemp, p_ordemcarga, v_codcat);
      valor_final := valor_atual + vlr_pedagio;
    else
      valor_final := valor_atual;
    end if;
  
    return valor_final;
  
  exception
    when error then
      raise_application_error(-20105, errmsg);
    when others then
      raise;
  end get_valor_oc_regfrete;

  procedure set_valor_rota(p_codemp     number,
                           p_ordemcarga number) is
    v_valor float;
    i       int := 0;
  begin
  
    select count(*)
      into i
      from ad_tsfrfv v
     where v.codemp = p_codemp
       and v.ordemcarga = p_ordemcarga;
  
    -- busca o valor da rota de acordo com a região de frete
    if check_carona(p_codemp, p_ordemcarga) then
      null;
    else
      v_valor := get_valor_oc_regfrete(p_codemp, p_ordemcarga);
    end if;
  
    -- merge
    if i = 0 then
      insert into ad_tsfrfv values (p_codemp, p_ordemcarga, 0, v_valor);
    else
      update ad_tsfrfv
         set vlrrota = v_valor
       where codemp = p_codemp
         and ordemcarga = p_ordemcarga;
    end if;
  
  end set_valor_rota;

  -- M. Rangel - Calcula o preço do frete para ordens de cargas caronas
  procedure set_dist_vlr_carona(p_codemp     number,
                                p_ordemcarga number,
                                p_distrota   float) is
    r1         tgford%rowtype;
    v_distrota float := p_distrota;
    v_vlrkm    float;
    v_peso     float;
  
    type type_rec_oc is record(
      codemp   number,
      ordcarga number,
      peso     float);
  
    type type_tab_oc is table of type_rec_oc;
    t type_tab_oc := type_tab_oc();
    i pls_integer;
  
    soma_pedagio varchar2(1);
  begin
  
    -- verifica se OC é carona
    if not check_carona(p_codemp, p_ordemcarga) then
      return;
    end if;
  
    begin
      select *
        into r1
        from tgford
       where codemp = p_codemp
         and ordemcarga = p_ordemcarga;
    exception
      when others then
        raise;
    end;
  
    -- percorre as OC com mesmo veículo e data 
    for c_ord in (select o.codemp, o.ordemcarga, o.codveiculo, o.codparcorig, o.codparctransp,
                         v.ad_codcat as codcat, o.dtinic,
                         case
                           when o.ordemcargapai > 0 then
                            'S'
                           else
                            'N'
                         end as carona, nvl(o.ad_vlrfreteproppeso, 'N') as fretepeso
                    from tgford o
                    join tgfvei v
                      on o.codveiculo = v.codveiculo
                   where o.codveiculo = r1.codveiculo
                     and o.codparctransp = r1.codparctransp
                     and o.dtinic = r1.dtinic
                   order by o.codemp)
    -- vai começar pela empresa 1 devido o order by
    loop
      t.extend;
      i := t.last;
    
      t(i).codemp := c_ord.codemp;
      t(i).ordcarga := c_ord.ordemcarga;
    
      -- percorre as regiões que estão dentro da ordem de carga
      for c_reg in (select p.codregfre, count(distinct p.codparc) qtdclientes,
                           count(distinct p.codcid) qtdcidades,
                           case
                             when count(distinct p.codcid) = 1 then
                              'S'
                             else
                              'N'
                           end as mesmodestino, sum(p.peso) peso
                      from ad_tsfrocp p
                    --tgfcab c Join tgfpar p On c.codparc = p.codparc
                     where p.codemp = c_ord.codemp
                       and p.ordemcarga = c_ord.ordemcarga
                    --And p.tipmov = 'P'
                     group by p.codregfre)
      loop
      
        t(i).peso := c_reg.peso;
      
        --pela ordem, quando entrar na regra da carona a variável já vai conter o peso total
        v_peso := nvl(v_peso, 0) + c_reg.peso;
      
        -- percorre as categorias dentro das regiões
        for c_cat in (select *
                        from ad_tsfrfr r
                       where r.codregfre = c_reg.codregfre
                         and r.codcat = c_ord.codcat)
        loop
          -- Lê as regras das caronas nas categorias
          for c_car in (select *
                          from ad_tsfrfa a
                          join ad_tsfrfr r
                            on r.nurfr = a.nurfr
                           and r.codregfre = a.codregfre
                         where a.codregfre = c_cat.codregfre
                           and a.nurfr = c_cat.nurfr
                           and r.codcat = c_cat.codcat
                           and a.codemp = c_ord.codemp
                           and a.codparcorig = c_ord.codparcorig
                           and c_reg.qtdclientes between a.qtdminclientes and a.qtdmaxclientes
                           and nvl(a.mesmodestino, 'N') = c_reg.mesmodestino)
          
          loop
          
            -- verifica se a ordem de carga se enquadra no pagamento por peso proporcional
            if c_ord.fretepeso is null then
              c_ord.fretepeso := check_fretepeso(p_codemp, p_ordemcarga);
            end if;
          
            /*km fixo*/
            if c_ord.carona = 'S' and c_ord.fretepeso = 'N' and c_car.aplicacao = 'F' then
              v_distrota := c_car.valor;
              v_vlrkm    := (v_distrota *
                            get_vlr_regfrete(c_car.codregfrevlr, c_cat.codcat, c_car.valor));
            
              /*peso*/
            elsif c_ord.carona = 'S' and c_ord.fretepeso = 'N' and c_car.aplicacao = 'P' then
              v_vlrkm := (c_reg.peso / 1000) * c_car.valor;
            
              /*km*/
            elsif c_ord.carona = 'S' and c_ord.fretepeso = 'N' and c_car.aplicacao = 'K' then
              v_vlrkm := (v_distrota *
                         get_vlr_regfrete(c_car.codregfrevlr, c_cat.codcat, c_car.valor));
            
              /*valor fixo*/
            elsif c_ord.carona = 'S' and c_ord.fretepeso = 'N' and c_car.aplicacao = 'VF' then
              v_vlrkm := c_car.valor;
            
              /*Peso proporcional Rota*/
            elsif c_ord.carona = 'S' and c_ord.fretepeso = 'S' and c_car.aplicacao = 'PP' then
            
              declare
                peso_total float := 0;
                valor_rota float;
                dist_rota  float;
              begin
                for z in t.first .. t.last
                loop
                  if t(z).codemp = 1 then
                  
                    select v.distrota
                      into dist_rota
                      from ad_tsfrocc v
                     where v.codemp = t(z).codemp
                       and v.ordemcarga = t(z).ordcarga;
                  
                    valor_rota := get_vlr_regfrete(c_car.codregfrevlr, c_cat.codcat, dist_rota);
                  
                    if nvl(soma_pedagio, 'N') = 'S' then
                      valor_rota := valor_rota +
                                    get_vlr_pedagio(t(z).codemp, t(z).ordcarga, c_cat.codcat);
                    end if;
                  
                    begin
                      merge into ad_tsfrfv r
                      using (select t(z).codemp as codemp,t(z).ordcarga as ordemcarga,
                                    dist_rota as distrota,
                                    ((valor_rota / v_peso) * t(z).peso) vlrrota
                               from dual) s
                      on (r.codemp = s.codemp and r.ordemcarga = s.ordemcarga)
                      when matched then
                        update set r.distrota = s.distrota, r.vlrrota = s.vlrrota
                      when not matched then
                        insert values (s.codemp, s.ordemcarga, s.distrota, s.vlrrota);
                    exception
                      when others then
                        raise;
                    end;
                  
                    begin
                      update ad_tsfrocc
                         set vlrrota =
                             ((valor_rota / v_peso) * t(z).peso)
                       where codemp = t(z).codemp
                         and ordemcarga = t(z).ordcarga;
                    exception
                      when others then
                        raise;
                    end;
                  
                  end if;
                  peso_total := peso_total + t(z).peso;
                  v_vlrkm    := ((valor_rota / v_peso) * t(z).peso);
                end loop;
              
                --valor_kilo := valor_rota / peso_total;
              
                /*Begin
                  Select distrota
                    Into v_distRota
                    From ad_tsfrocc c
                   Where c.codemp = c_ord.codemp
                     And c.ordemcarga = c_ord.ordemcarga;
                Exception
                  When Others Then
                    Raise;
                End;*/
              
                --v_vlrKm := v_distRota * valor_kilo;
              
              end;
            
              /*Peso proporcional Transbordo*/
            elsif c_ord.carona = 'S' and c_ord.fretepeso = 'S' and c_car.aplicacao = 'PT' then
            
              declare
                peso_carga  float := 0;
                peso_carona float := 0;
              begin
                for z in t.first .. t.last
                loop
                  if t(z).codemp = 1 then
                    peso_carga := peso_carga + t(z).peso;
                  elsif t(z).codemp != 1 then
                    peso_carona := peso_carona + t(z).peso;
                  end if;
                end loop;
              
                v_vlrkm := round(peso_carona / peso_carga, 2) * c_car.valor;
              
              end;
            
            end if;
          
            if nvl(v_distrota, 0) > 0 and nvl(v_vlrkm, 0) > 0 then
            
              begin
              
                if nvl(soma_pedagio, 'N') = 'S' then
                  v_vlrkm := v_vlrkm +
                             get_vlr_pedagio(c_ord.codemp, c_ord.ordemcarga, c_cat.codcat);
                end if;
              
                merge into ad_tsfrfv r
                using (select c_ord.codemp as codemp, c_ord.ordemcarga as ordemcarga,
                              v_distrota as distrota, v_vlrkm as vlrrota
                         from dual) d
                on (r.codemp = d.codemp and r.ordemcarga = d.ordemcarga)
                when matched then
                  update set r.distrota = d.distrota, r.vlrrota = d.vlrrota
                when not matched then
                  insert
                    (codemp, ordemcarga, distrota, vlrrota)
                  values
                    (d.codemp, d.ordemcarga, d.distrota, d.vlrrota);
              
                begin
                  update ad_tsfrocc
                     set vlrrota = v_vlrkm
                   where codemp = p_codemp
                     and ordemcarga = p_ordemcarga;
                exception
                  when others then
                    raise;
                end;
              
                dbms_output.put_line('Distância: ' || ' | ' || v_distrota);
                dbms_output.put_line('Valor Km: ' || ' | ' || v_vlrkm);
              
              exception
                when others then
                  raise;
              end;
            
            end if;
          
          end loop c_car;
        
        end loop c_cat;
      
      end loop c_reg;
    
    end loop c_ord;
  
  end set_dist_vlr_carona;

  procedure atualiza_coord_parc(p_codparc number,
                                p_coord   out varchar2,
                                p_link    out varchar2,
                                p_errmsg  out varchar2) is
    v_endereco varchar2(1000);
    req        utl_http.req;
    resp       utl_http.resp;
    xml        varchar2(32767);
    i          int := 1;
    x          xmltype;
    status     varchar2(100);
    url        varchar2(1000);
    lat        varchar2(200);
    lng        varchar2(200);
  begin
    /*
    * Autor: Marcus Rangel
    * Objetivo: Método que busca a latitude e a longitude do parceiro
    * no google maps, similar ao botão mapas no cadastro de parceiro, 
    * porém, pode ser usado para operações em lote.
    */
    <<monta_pesquisa>>
  
    if i = 1 then
    
      /*pesquisa sem o nome e sem o cep*/
      select e.tipo || '+' || replace(e.nomeend, ' ', '+') || ',' ||
              decode(p.numend, 'SN', '', p.numend || ',') || /* Replace(p.complemento, ' ', '+') || ',' ||*/
              replace(ltrim(rtrim(b.nomebai)), ' ', '+') || ',' ||
              replace(ltrim(rtrim(c.nomecid)), ' ', '+') || '-' || u.uf
        into v_endereco
        from tgfpar p
        join tsiend e
          on p.codend = e.codend
        join tsibai b
          on p.codbai = b.codbai
        join tsicid c
          on p.codcid = c.codcid
        join tsiufs u
          on c.uf = u.coduf
       where p.codparc = p_codparc;
    
    elsif i = 2 then
    
      /*pesquisa sem o nome do parceiro com cep*/
      select e.tipo || '+' || replace(e.nomeend, ' ', '+') || ',' || p.numend || ',' || /*Replace(p.complemento, ' ', '+') || ',' ||*/
              replace(ltrim(rtrim(b.nomebai)), ' ', '+') || ',' ||
              replace(ltrim(rtrim(c.nomecid)), ' ', '+') || '-' || u.uf || ', CEP+' || p.cep
        into v_endereco
        from tgfpar p
        join tsiend e
          on p.codend = e.codend
        join tsibai b
          on p.codbai = b.codbai
        join tsicid c
          on p.codcid = c.codcid
        join tsiufs u
          on c.uf = u.coduf
       where p.codparc = p_codparc;
    
    elsif i = 3 then
    
      /*pesquisa pelo nome do parceiro e endereço completo */
      select replace(replace(ltrim(rtrim(substr(p.nomeparc, 1,
                                                case
                                                   when instr(p.nomeparc, '-', -1, 1) - 1 = -1 then
                                                    length(p.nomeparc)
                                                   else
                                                    instr(p.nomeparc, '-', -1, 1) - 1
                                                 end))), ' ', '+') || ',' || e.tipo || '+' ||
                     replace(e.nomeend, ' ', '+') || ',' || p.numend || ',' || /*Replace(p.complemento, ' ', '+') || ',' || */
                     replace(ltrim(rtrim(b.nomebai)), ' ', '+') || ',' ||
                     replace(ltrim(rtrim(c.nomecid)), ' ', '+') || '-' || u.uf, ',,', ',')
        into v_endereco
        from tgfpar p
        join tsiend e
          on p.codend = e.codend
        join tsibai b
          on p.codbai = b.codbai
        join tsicid c
          on p.codcid = c.codcid
        join tsiufs u
          on c.uf = u.coduf
       where p.codparc = p_codparc;
    
    elsif i = 4 then
    
      /*pesquisa pelo nome do parceiro com bairro, cidade e uf */
      select replace(replace(ltrim(rtrim(substr(p.nomeparc, 1,
                                                case
                                                   when instr(p.nomeparc, '-', -1, 1) - 1 = -1 then
                                                    length(p.nomeparc)
                                                   else
                                                    instr(p.nomeparc, '-', -1, 1) - 1
                                                 end))), ' ', '+') || ',' ||
                     replace(ltrim(rtrim(b.nomebai)), ' ', '+') || ',' ||
                     replace(ltrim(rtrim(c.nomecid)), ' ', '+') || '-' || u.uf, ',,', ',')
        into v_endereco
        from tgfpar p
        join tsiend e
          on p.codend = e.codend
        join tsibai b
          on p.codbai = b.codbai
        join tsicid c
          on p.codcid = c.codcid
        join tsiufs u
          on c.uf = u.coduf
       where p.codparc = p_codparc;
    else
      p_errmsg := 'Nenhum Resultado encontrado';
      return;
    end if;
  
    url := 'https://maps.googleapis.com/maps/api/geocode/xml?address=' || v_endereco || '&key=' ||
           get_tsipar_texto('CHAVEGOOGLEMAP');
  
    utl_http.set_wallet('file:/u01/app/oracle/admin/orcl/geo_wallet', 'Sf29zx47');
  
    req := utl_http.begin_request(url);
    utl_http.set_header(req, 'User-Agent', 'Mozilla/4.0');
    resp := utl_http.get_response(req);
    utl_http.read_text(resp, xml, 32767);
    x := xmltype(xml);
  
    status := x.extract('/GeocodeResponse/status/text()').getstringval;
  
    if nvl(status, 'N') = 'OK' then
    
      lat := substr(x.extract('/GeocodeResponse/result/geometry/location/lat/text()').getstringval,
                    1, 11);
      lng := substr(x.extract('/GeocodeResponse/result/geometry/location/lng/text()').getstringval,
                    1, 11);
    
      if lat is not null and lng is not null then
      
        begin
          update tgfpar set latitude = lat, longitude = lng where codparc = p_codparc;
        
        exception
          when others then
            raise;
        end;
      
      end if;
    
    elsif nvl(status, 'N') = 'ZERO_RESULTS' then
      i   := i + 1;
      xml := null;
      url := null;
      utl_http.end_request(req);
      utl_http.end_response(resp);
      goto monta_pesquisa;
    end if;
  
    utl_http.end_request(req);
    utl_http.end_response(resp);
    xml := null;
  
    p_coord := lat || ',' || lng;
    p_link  := 'https://www.google.com.br/maps/place/' || lat || ',' || lng;
  
  exception
    when utl_http.end_of_body then
      utl_http.end_response(resp);
      utl_http.end_request(req);
      p_errmsg := 'Serviço inalcançável, tente novamente.';
    when others then
      p_errmsg := sqlerrm;
      utl_http.end_response(resp);
      utl_http.end_request(req);
  end atualiza_coord_parc;

  procedure grava_coordenadas(p_coord_orig varchar2,
                              p_coord_dest varchar2,
                              p_distancia  float,
                              p_errmsg     out varchar2) is
  begin
    insert into ad_tsfrfdg
      (dtalter, coordorig, coorddest, distancia)
    values
      (sysdate, p_coord_orig, p_coord_dest, p_distancia);
  
    commit;
  
  exception
    when dup_val_on_index then
      return;
    when others then
      p_errmsg := sqlerrm;
      return;
  end grava_coordenadas;

  function get_distancia_xml(v_coord_orig varchar2,
                             v_coord_dest varchar2) return float is
    v_url        varchar2(1000);
    header       varchar2(100);
    key          varchar2(100);
    req          utl_http.req;
    resp         utl_http.resp;
    conteudo_xml varchar2(32767);
    status       varchar2(100);
    status_row   varchar2(100);
    v_xml        xmltype;
    v_kmchar     varchar2(10);
    v_km         float;
    un           char(2);
    errmsg       varchar2(4000);
    error exception;
  begin
  
    -- pesquisa na tabela de distâncias por coordenadas
    begin
      select distancia
        into v_km
        from ad_tsfrfdg d
       where d.coordorig = v_coord_orig
         and d.coorddest = v_coord_dest
         and d.dtalter = (select max(d2.dtalter)
                            from ad_tsfrfdg d2
                           where d2.dtalter <= sysdate
                             and d2.coordorig = v_coord_orig
                             and d2.coorddest = v_coord_dest);
    
    exception
      when no_data_found then
        v_km := 0;
      when others then
        v_km := 0;
    end;
  
    if v_km is not null and v_km > 0 then
      return v_km;
    else
    
      if resp.private_hndl is not null then
        utl_http.end_response(resp);
      end if;
    
      if req.private_hndl is not null then
        utl_http.end_request(req);
      end if;
    
      utl_http.set_response_error_check(true);
      utl_http.set_detailed_excp_support(true);
    
      --utl_http.set_wallet(Path => 'file:/u01/app/oracle/admin/orcl/wallet', password => '@Sf29zx47#'); --dev
      --Utl_http.Set_wallet('file:/u01/app/oracle/admin/orcl/geo_wallet', 'Sf29zx47');
      utl_http.set_wallet('file:/u01/app/oracle/admin/orcl/geo_wallet', 'sf29zx47');
      header := 'https://maps.googleapis.com/maps/api/distancematrix/xml?';
      key    := '&key=' || get_tsipar_texto('CHAVEGOOGLEMAP');
      v_url  := header || 'origins=' || v_coord_orig || '&destinations=' || v_coord_dest ||
                '&mode=driving&language=pt-BR&sensor=false' || key;
      v_url  := replace(v_url, ' ', '');
      req    := utl_http.begin_request(v_url);
      utl_http.set_header(req, 'User-Agent', 'Mozilla/4.0');
      resp := utl_http.get_response(req);
      utl_http.read_text(resp, conteudo_xml, 32767);
      v_xml := xmltype(conteudo_xml);
    
      status := v_xml.extract('/DistanceMatrixResponse/status/text()').getstringval;
    
      if status != 'OK' then
        errmsg := 'Erro ao pesquisar coordenadas - ' || status;
        raise error;
      end if;
    
      status_row := v_xml.extract('/DistanceMatrixResponse/row/element/status/text()').getstringval;
    
      if status_row = 'ZERO_RESULTS' or status_row = 'NOT_FOUND' then
        v_km := 0;
      else
        v_km     := to_number(v_xml.extract('/DistanceMatrixResponse/row/element/distance/value/text()').getstringval);
        v_kmchar := upper(v_xml.extract('/DistanceMatrixResponse/row/element/distance/text/text()').getstringval);
        un       := rtrim(ltrim(upper(substr(v_kmchar, instr(v_kmchar, ' ', 1, 1), length(v_kmchar)))));
      
        v_km := case
                  when v_km > 0 and un = 'KM' then
                   v_km / 1000
                  when v_km > 0 and un = 'M' then
                   v_km / 100
                  else
                   0
                end;
      end if;
    
      utl_http.end_request(req);
      utl_http.end_response(resp);
    
      --grava as coordenadas na tabela de coordenadas TSFRFDG
      grava_coordenadas(v_coord_orig, v_coord_dest, v_km, errmsg);
    
      if errmsg is not null then
        --ad_set.insere_msglog('Erro ao gravar distância entre coordanadas. ' || ErrMsg);
        raise error;
      end if;
    
    end if;
    --Dbms_Output.put_line('request google');
  
    return v_km;
  
  exception
    when error then
    
      if resp.private_hndl is not null then
        utl_http.end_response(resp);
      end if;
    
      if req.private_hndl is not null then
        utl_http.end_request(req);
      end if;
    
      errmsg := errmsg || ' - ' || sqlerrm;
    
      raise_application_error(-20105, errmsg);
    
    when others then
      utl_http.end_response(resp);
      utl_http.end_request(req);
      raise;
  end get_distancia_xml;

  /*Calcula a sequencia da ordem de carga pela distância entre parceiros*/
  procedure set_sequencia_rota(p_codemp     number,
                               p_ordemcarga number,
                               p_errmsg     out varchar2) is
    v_count        int;
    v_codpacrorig  number;
    v_coordorig    varchar2(25);
    v_distancia    float;
    v_distotal     float := 0;
    ponto_final    varchar2(25);
    l_dist_tab     ad_type_fre_disttable := ad_type_fre_disttable();
    l_dist_tab_ord ad_type_fre_disttable := ad_type_fre_disttable();
    x              int;
    v_ultseq       int;
    l_rec_seq      ad_type_of_number := ad_type_of_number();
    l_idx          int;
  
    erro_valor exception;
    pragma exception_init(erro_valor, -06502);
  
  begin
  
    -- Verifica a qtde de registros na OC, usado no loop
    select count(distinct codparc)
      into v_count
      from tgfcab
     where codemp = p_codemp
       and ordemcarga = p_ordemcarga
       and tipmov = 'V'
       and statusnota = 'L'
       and seqcarga = 0;
  
    -- verifica se existe origem definida pelo usuário 
    select nvl(max(seqcarga), 0)
      into v_ultseq
      from tgfcab
     where codemp = p_codemp
       and ordemcarga = p_ordemcarga
       and tipmov = 'V'
       and statusnota = 'L'
       and nvl(seqcarga, 0) > 0;
  
    --- define quem é o parceiro inicio da OC
    if nvl(v_ultseq, 0) > 0 then
      select p.codparc, p.latitude || '%2C' || p.longitude coordparc
        into v_codpacrorig, v_coordorig
        from tgfcab c, tgfpar p
       where p.codparc = c.codparc
         and c.codemp = p_codemp
         and c.ordemcarga = p_ordemcarga
         and c.tipmov = 'V'
         and c.statusnota = 'L'
         and nvl(c.seqcarga, 0) = v_ultseq;
    else
      select p.codparc, p.latitude || '%2C' || p.longitude coordparc
        into v_codpacrorig, v_coordorig
        from tgfpar p, tgford o
       where p.codparc = o.codparcorig
         and o.codemp = p_codemp
         and o.ordemcarga = p_ordemcarga;
    end if;
  
    -- percorre as notas buscando os parceiros
    for i in 1 .. v_count
    loop
      -- limpa a coleção
      l_dist_tab.delete;
    
      -- inner loop para preencher os demais valores da coleção
      -- não rodou com bulk, devido a proc dentro do object type, ordem de exceução
      for c in (select distinct p.codparc,
                                to_char(substr(p.latitude, 1, 9) || '%2C' ||
                                         substr(p.longitude, 1, 9)) coord
                  from tgfpar p, tgfcab c
                 where c.codparc = p.codparc
                   and c.codemp = p_codemp
                   and c.ordemcarga = p_ordemcarga
                   and c.tipmov = 'V'
                   and c.statusnota = 'L'
                   and nvl(c.seqcarga, 0) = 0
                   and p.codparc not in (select * from table(l_rec_seq))
                 order by 1)
      loop
        v_distancia := ad_pkg_fre.get_distancia_xml(v_coordorig, c.coord);
        l_dist_tab.extend;
        x := l_dist_tab.last;
        l_dist_tab(x) := ad_type_fre_distobject(c.codparc, c.coord, v_distancia);
      end loop;
    
      -- ordena a coleção pela menor distância  
      select cast(multiset
                   (select codparc, coord, distancia from table(l_dist_tab) order by distancia) as
                   ad_type_fre_disttable)
        into l_dist_tab_ord
        from dual;
    
      l_rec_seq.extend;
    
      l_idx := l_rec_seq.last;
    
      l_rec_seq(l_idx) := l_dist_tab_ord(1).codparc;
    
      v_codpacrorig := l_dist_tab_ord(1).codparc;
    
      v_coordorig := l_dist_tab_ord(1).coord;
    
      ponto_final := l_dist_tab_ord(1).coord;
    
      v_distotal := v_distotal + l_dist_tab_ord(1).distancia;
    
    end loop;
  
    -- atualiza as notas da OC
    for z in l_rec_seq.first .. l_rec_seq.last
    loop
      dbms_output.put_line(z || ' - ' || l_rec_seq(z));
    
      begin
        update tgfcab
           set seqcarga = z + v_ultseq
         where ordemcarga = p_ordemcarga
           and codemp = p_codemp
           and tipmov = 'V'
           and statusnota = 'L'
           and codparc = l_rec_seq(z);
      
      exception
        when others then
          p_errmsg := '(' || l_rec_seq(z) || ') ' || sqlerrm;
          --Raise;
          return;
      end;
    
    end loop;
  
  exception
    when others then
      raise;
      /*When Erro_valor Then
      p_ErrMsg := 'Problema na informação contida na sequência de Entrega';*/
  
  end set_sequencia_rota;

  --M. Rangel
  /*busca o valor do evento de transporte, o nome coincide com o nome usado no construtor 
  de fórmula para ser utilizado dinamicamente*/
  function ocevento(p_codveiculo number,
                    p_codevento  number) return float is
    vlrevento float;
  begin
    begin
      select valor
        into vlrevento
        from tgfevevei eve
       where eve.codveiculo = p_codveiculo
         and eve.codevento = p_codevento
         and eve.dtref = (select max(dtref)
                            from tgfevevei i
                           where i.codveiculo = eve.codveiculo
                             and i.codevento = eve.codevento
                             and i.dtref < sysdate);
    exception
      when others then
        vlrevento := 0;
    end;
  
    return vlrevento;
  end ocevento;

  --M. Rangel
  /* Calcula o valor do frete utilzando as fórmulas de frete, simulando o processo nativo do sistema*/
  function get_vlrfrete_formula(p_nunota     number,
                                p_codemp     number,
                                p_codparc    number,
                                p_ordemcarga number,
                                p_codveiculo number) return float is
    o tgford%rowtype;
    v tgfvei%rowtype;
  
    type type_totais is record(
      distancia float,
      valor     float);
  
    totais type_totais;
  
    v_formula varchar2(4000);
  
  begin
  
    select * into v from tgfvei where codveiculo = p_codveiculo;
  
    select *
      into o
      from tgford
     where codemp = p_codemp
       and ordemcarga = p_ordemcarga;
  
    -- distancia
    totais.distancia := ad_pkg_fre.distancia_entre_parceiros(o.codparcorig, p_codparc) * 2;
  
    if o.tipcalcfrete = 1 then
    
      begin
        select lower(f.formula)
          into v_formula
          from tsifor f
         where tipform = 'F'
           and codform = v.codformfrete;
      exception
        when no_data_found then
          raise;
      end;
    
      v_formula := replace(v_formula, 'totais.distancia',
                           replace(to_char(totais.distancia), ',', '.'));
      v_formula := replace(v_formula, 'ocevento(', 'ad_pkg_fre.ocevento(' || v.codveiculo || ',');
    
      dbms_output.put_line('Select ' || v_formula || ' from dual');
    
      execute immediate 'Select ' || v_formula || ' from dual'
        into totais.valor;
    
      dbms_output.put_line(v_formula);
    
    end if;
  
    dbms_output.put_line(totais.valor);
    return totais.valor;
  
  end get_vlrfrete_formula;

  --M. Rangel
  /* Método para realizar a atualização do valor do frete no pedido/nota */
  procedure set_vlrfrete_formula(p_nunota     number,
                                 p_codemp     number,
                                 p_codparc    number,
                                 p_ordemcarga number,
                                 p_codveiculo number,
                                 p_errmsg     out varchar2) is
    valorfrete float;
  begin
    valorfrete := get_vlrfrete_formula(p_nunota, p_codemp, p_codparc, p_ordemcarga, p_codveiculo);
  
    begin
      update tgfcab set vlrfrete = valorfrete where nunota = p_nunota;
    exception
      when others then
        p_errmsg := 'Erro ao atualizar o valor do frete na TGFCAB. ' || sqlerrm;
        return;
    end;
  
  end set_vlrfrete_formula;

  function get_regioes_oc(p_codemp number,
                          p_oc     number) return varchar2 as
  begin
  
    select listagg(codreg, ',') within group(order by codreg) regioes
      into ad_pkg_var.resultv
      from (select distinct p.ad_codregfre codreg
               from tgfpar p
              where codparc in (select codparc
                                  from tgfcab
                                 where ordemcarga = p_oc
                                   and codemp = p_codemp
                                   and tipmov = 'V')
                and nvl(p.ad_codregfre, 0) > 0);
  
    return ad_pkg_var.resultv;
  exception
    when others then
      return sqlerrm;
  end get_regioes_oc;

  -- calculo do valor da rota usando os valores de distância  do HBSIS
  procedure set_valor_rota_hbsis(p_dtini date,
                                 p_dtfin date) is
    valor_atual float;
    vlr_pedagio float;
  begin
    for reg in (
                
                select o.codemp, o.ordemcarga, o.ad_kmrota distancia, cat.codcat,
                        par.ad_codregfre codreg
                  from tgford o
                  join tgfvei v
                    on o.codveiculo = v.codveiculo
                  join ad_tsfcat cat
                    on cat.codcat = v.ad_codcat
                  join tgfcab cab
                    on cab.codemp = o.codemp
                   and cab.ordemcarga = o.ordemcarga
                   and cab.tipmov = 'V'
                  join tgfpar par
                    on par.codparc = cab.codparc
                 where o.dtinic between p_dtini and p_dtfin
                   and o.codveiculo > 0
                   and o.ad_kmrota > 0
                 group by o.codemp, o.ordemcarga, o.ad_kmrota, cat.codcat, par.ad_codregfre
                having par.ad_codregfre > 0
                
                )
    loop
    
      valor_atual := get_vlr_regfrete(p_codregfre => reg.codreg, p_codcat => reg.codcat,
                                      p_distancia => reg.distancia);
    
      merge into ad_tsfrfv r
      using (select reg.codemp codemp, reg.ordemcarga ordemcarga, reg.distancia dist,
                    valor_atual as vlrtot
               from dual) d
      on (d.codemp = r.codemp and d.ordemcarga = r.ordemcarga)
      when matched then
        update set distrota = dist, vlrrota = d.vlrtot
      when not matched then
        insert values (d.codemp, d.ordemcarga, d.dist, d.vlrtot);
    
    end loop;
  
  end;

end ad_pkg_fre;
/
