create or replace package ad_pkg_newdre authid current_user is

  /****************************************************************************
  autor: marcus rangel
  processo: dre
  objetivo: conter todos os métodos utilizados na geração,calculo e obtenção de
  valores da dre.
  *****************************************************************************/

  --> métodos auxiliares <--

  /* busca a cidade do parceiro - utilizada na query principal da fórmula */
  function get_cid_transbordo(p_ordemcarga int) return int deterministic;

  /* busca o valor do pis,cofins e dos créditos - utilizada na criação 
  da base do indicador padrão - herança da outra dre */
  function get_aliq_piscofins(p_codprod number,
                              p_nomeimp varchar2,
                              p_top number) return float deterministic;

  -- calcula o frete e peso do cross dock
  procedure aux_set_fretepesocross(p_referencia date,
                                   p_errmsg out nocopy varchar2);

  /*function get_vlr_fretecross(p_codcid int,
  p_codemp int,
  p_vlrtrx float,
  p_dtref  date,
  p_tipo   char) return float deterministic;*/

  -- valida formulas de exceções
  procedure aux_valida_excformulas(p_msg out nocopy varchar2);

  --> métodos de retornos <--

  function get_qtdtotal(p_referencia date,
                        p_codemp number) return float deterministic;

  function get_qtdtotal(p_referencia date,
                        p_codemp int,
                        p_codune int,
                        p_coduf int,
                        p_codprod number) return float deterministic;

  function get_resindpad(p_referencia date,
                         p_codindpad number,
                         p_codprod number,
                         p_codemp number,
                         p_codune number,
                         p_coduf int) return float;

  function get_resindger(p_referencia date,
                         p_codind int,
                         p_codemp number,
                         p_codune number,
                         p_coduf number) return float deterministic;

  function get_vlrdescfin(p_referencia date,
                          p_codemp number,
                          p_codune number,
                          p_coduf number,
                          p_codprod number) return float deterministic;

  function get_vlrcusto_dre(p_referencia date,
                            p_codprod number,
                            p_codemp number,
                            p_tipo char) return float;

  function get_vlrcusto_dre(p_referencia date,
                            p_codprod number,
                            p_codemp int) return float deterministic;

  /* -- cria as tabelas
  procedure cria_tabelabase(p_tipo     pls_integer,
                            p_mensagem out nocopy varchar2);*/

  /* preenchimento de dados necessários para o calculo */
  procedure set_baseindpad(p_referencia date,
                           p_mensagem out nocopy varchar2);

  procedure set_basedesccom(p_referencia date,
                            p_mensagem out nocopy varchar2);

  procedure set_basecusto(p_referencia date,
                          p_mensagem out nocopy varchar2);

  procedure set_basefinreqrat(p_referencia date,
                              p_mensagem out nocopy varchar2);

  procedure set_baseindger(p_referencia date,
                           p_mensagem out nocopy varchar2);

  /* calculos dos indicadores */

  procedure set_resindger(p_referencia date,
                          p_codindger number,
                          p_mensagem out nocopy varchar2);

  procedure set_rentabcom(p_referencia date,
                          p_codindpad int,
                          p_mensagem out nocopy varchar2);

  procedure set_resindpad(p_referencia date,
                          p_codindpad pls_integer default null,
                          p_mensagem out nocopy varchar2);

  procedure get_relacionamento_indpad(p_codind number,
                                      p_array out nocopy ad_type_of_number);

  procedure executeagendamento;

  procedure insereeventolog(p_referencia date,
                            p_evento varchar2,
                            p_status char,
                            p_errmsg clob);

end ad_pkg_newdre;
/
create or replace package body ad_pkg_newdre is

  /* rotina que grava log de operação */
  procedure insereeventolog(p_referencia date,
                            p_evento varchar2,
                            p_status char,
                            p_errmsg clob) is
  begin
    -- status, 1 para sucesso, -1 para falha
    insert into dre_logeventos
      (dtref, evento, dhevento, status, errmsg)
    values
      (p_referencia, p_evento, sysdate, p_status, p_errmsg);
  end insereeventolog;

  /* busca a cidade do parceiro - utilizada na query principal da fórmula */
  function get_cid_transbordo(p_ordemcarga int) return int deterministic is
    result int;
  begin
    begin
      select p.codcid
        into result
        from tgfpar p
        join tgfcab c
          on c.codparc = p.codparc
        join tgford o
          on o.ordemcargapai = c.ordemcarga
       where o.ordemcarga = p_ordemcarga
       group by p.codcid;
    exception
      when others then
        result := 0;
    end;
    return result;
  end get_cid_transbordo;

  /* busca o valor do pis,cofins e dos créditos - utilizada na criação 
  da base do indicador padrão - herança da outra dre */
  function get_aliq_piscofins(p_codprod number,
                              p_nomeimp varchar2,
                              p_top number) return float deterministic is
    v_grupo varchar2(100);
    v_aliq  float;
  
    type type_rec_prod is record(
      grupopis varchar2(100),
      grupocof varchar2(100),
      credmp   number);
  
    r type_rec_prod;
  
  begin
  
    select grupopis, grupocofins, credmp2 into r.grupopis, r.grupocof, r.credmp from tgfpro p where p.codprod = p_codprod;
  
    if p_nomeimp = 'PIS' then
      v_grupo := r.grupopis;
    else
      v_grupo := r.grupocof;
    end if;
  
    begin
      select i.aliq
        into v_aliq
        from tgfife i
       where i.nomeimp = p_nomeimp
         and i.grupoimp = v_grupo
         and codtipoper = p_top;
    exception
      when no_data_found then
        select i.aliq
          into v_aliq
          from tgfife i
         where i.nomeimp = p_nomeimp
           and i.grupoimp = v_grupo
           and codtipoper = 0
           and entsai = 'S';
    end;
  
    return v_aliq;
  
  end get_aliq_piscofins;

  /* envia o valor do frete calculado e o peso total por cidade da vgfcross */
  procedure aux_set_fretepesocross(p_referencia date,
                                   p_errmsg out nocopy varchar2) is
  
    type t_baseind is table of dre_baseindpad%rowtype;
    l_base t_baseind;
  
    stmt varchar2(4000);
    c    sys_refcursor;
    --p_dtref date := '01/04/2020';
  
    --x int := 0;
  
  begin
  
    for cross in (select codcid, frete, peso from vgfcross where referencia = p_referencia)
    loop
    
      stmt := 'select * 
      from dre_baseindpad 
      where dtref = :dtref 
      and vlrfretecross is null
      and pesocross is null
      and case 
       when cidcross = 0 and codemp != 1 and vlrtrx > 0 
        then 
         ad_get.codcidparcemp(codemp, ''E'')
        else
         cidcross
         end = :codcid';
    
      open c for stmt
        using p_referencia, cross.codcid;
      loop
        fetch c bulk collect
          into l_base limit 10000;
        exit when l_base.count = 0;
      
        forall i in l_base.first .. l_base.last
          update dre_baseindpad
             set vlrfretecross = cross.frete,
                 pesocross     = cross.peso
           where dtref = p_referencia
             and nunota = l_base(i).nunota
             and sequencia = l_base(i).sequencia;
      
      end loop;
    
      close c;
    
    end loop;
  
  end aux_set_fretepesocross;

  /*procedure aux_set_fretepesocross(p_referencia date,
                                   p_errmsg     out nocopy varchar2) is
  begin
    for cid in (select *
                  from vgfcross
                 where referencia = p_referencia)
    loop
      begin
        update dre_baseindpad
           set vlrfretecross = cid.frete,
               pesocross     = cid.peso,
               cidcross      = cid.codcid
         where dtref = cid.referencia
           and case
                 when cidcross > 0 then
                  cidcross
                 else
                  case
                    when codemp <> 1 and vlrtrx > 0 then
                     ad_get.codcidparcemp(codemp, 'E')
                  end
               end = cid.codcid;
        commit;
      exception
        when others then
          p_errmsg := sqlerrm;
      end;
    
    end loop;
  end;*/

  /*function get_vlr_fretecross(p_codcid int,
                              p_codemp int,
                              p_vlrtrx float,
                              p_dtref  date,
                              p_tipo   char) return float deterministic is
    v_valor  float;
    v_peso   float;
    v_codcid int;
    v_result float;
  begin
    v_codcid := case
                  when nvl(p_codcid, 0) > 0 then
                   p_codcid
                  when nvl(p_codcid, 0) = 0 and p_codemp != 1 and p_vlrtrx > 0 then
                   ad_get.codcidparcemp(p_codemp, 'E')
                end;
  
    select frete, peso
      into v_valor, v_peso
      from vgfcross v
     where v.referencia = p_dtref
       and v.codcid = v_codcid;
  
    if p_tipo = 'F' then
      return v_valor;
    elsif p_tipo = 'P' then
      return v_peso;
    else
      return 0;
    end if;
  
    return v_valor;
  end;*/

  /*procedure aux_set_fretepesocross(p_referencia date,
                                   p_errmsg     out nocopy varchar2) is
  
    type type_rec_cidcross is record(
      id     rowid,
      codcid number);
  
    type type_tab_cidcross is table of type_rec_cidcross;
  
    t type_tab_cidcross := type_tab_cidcross();
  
    c vgfcross%rowtype;
  
    c_cid sys_refcursor;
  
  begin
    v_sufixo := to_char(p_referencia, 'YYYYMM');
  
    stmt := 'Select Rowid,  ' || 'Case When cidcross > 0 Then cidcross Else ' ||
            'Case When codemp <> 1 And vlrtrx > 0 Then ' ||
            'ad_get.Codcidparcemp(codemp,''E'') End ' || 'End From dre_baseindpad ' ||
            'Where dtref = :dtref ' || ' and Case When cidcross > 0 Then cidcross ' ||
            'Else Case When codemp <> 1 And vlrtrx > 0 Then ' ||
            ' ad_get.Codcidparcemp(codemp,''E'') End ' || 'End = :codcid';
  
    for c in (select * from vgfcross where referencia = p_referencia)
    loop
    
      open c_cid for stmt
        using p_referencia, c.codcid;
      loop
        fetch c_cid bulk collect
          into t limit 10000;
        exit when c_cid%notfound;
      end loop;
      close c_cid;
    
      begin
        forall z in t.first .. t.last save exceptions
          update dre_baseindpad
             set vlrfretecross = c.frete,
                 pesocross     = c.peso,
                 cidcross      = case
                                   when cidcross > 0 then
                                    cidcross
                                   else
                                    case
                                      when codemp <> 1 and vlrtrx > 0 then
                                       ad_get.codcidparcemp(codemp, 'E')
                                    end
                                 end
           where dtref = p_referencia
             and case
                   when cidcross > 0 then
                    cidcross
                   else
                    case
                      when codemp <> 1 and vlrtrx > 0 then
                       ad_get.codcidparcemp(codemp, 'E')
                    end
                 end = t(z).codcid
             and rowid = t(z).id;
      exception
        when others then
          for e in 1 .. sql%bulk_exceptions.count
          loop
            p_errmsg := p_errmsg || chr(13) || sql%bulk_exceptions(e).error_index || ': ' || sql%bulk_exceptions(e).error_code;
          end loop;
          raise_application_error(-20105, p_errmsg);
      end;
    
    end loop c;
  
  end aux_set_fretepesocross;*/

  procedure get_relacionamento_indpad(p_codind number,
                                      p_array out nocopy ad_type_of_number) is
    v_newind number;
    v_oldind number;
    --v_formula varchar2(4000);
    t1 ad_type_of_number := ad_type_of_number();
    t2 ad_type_of_number := ad_type_of_number();
    t3 ad_type_of_number := ad_type_of_number();
    x  int;
  
    v_newabv dre_cadindpad.abrev%type;
    v_oldabv dre_cadindpad.abrev%type;
  begin
    --p_codind := 7;
    p_array  := ad_type_of_number();
    v_newind := p_codind;
  
    while v_newind > 0
    loop
    
      -- executa para o indicador
      --dbms_output.put_line(v_newind);
      select abrev
        into v_newabv
        from dre_cadindpad
       where ativo = 'S'
         and codindpad = v_newind;
    
      t1.extend;
      x := t1.last;
      t1(x) := v_newind;
    
      -- busca dependentes
      begin
        select f.codindpad
          into v_newind
          from dre_forindpad f
          join dre_cadindpad c
            on c.codindpad = f.codindpad
         where c.ativo = 'S'
           and c.totalizador = 'S'
              --and nvl(f.ignorar, 'N') = 'N'
           and upper(formindpad) like '%' || upper(v_newabv) || '%'
           and f.dhvigor = (select max(f2.dhvigor)
                              from dre_forindpad f2
                             where f2.codindpad = f.codindpad
                            --and nvl(f2.ignorar, 'N') = 'N'
                            )
         order by f.codindpad;
      exception
        when no_data_found then
          v_newind := 0;
        when too_many_rows then
          for dep in (select rownum, f.codindpad
                        from dre_forindpad f
                        join dre_cadindpad c
                          on c.codindpad = f.codindpad
                       where c.ativo = 'S'
                         and c.totalizador = 'S'
                            --and nvl(f.ignorar, 'N') = 'N'
                         and upper(formindpad) like '%' || upper(v_newabv) || '%'
                         and f.dhvigor = (select max(f2.dhvigor)
                                            from dre_forindpad f2
                                           where f2.codindpad = f.codindpad
                                          --and nvl(f2.ignorar, 'N') = 'N'
                                          )
                       order by f.codindpad)
          loop
            if dep.rownum > 1 then
              t2.extend;
              x := t2.last;
              t2(x) := dep.codindpad;
            end if;
          end loop;
          continue;
      end;
      v_oldind := v_newind;
      v_oldabv := v_newabv;
    end loop;
  
    --- tratativa para duplicados e já calculados na mesma runtime
    if t2 submultiset of t1 then
      t3 := t1;
    else
      t3 := t1 multiset union distinct t2;
    end if;
  
    -- verifica as fórmulas dos totalizadores, verificando relacionamento entre eles
    for i in t3.first .. t3.last
    loop
      select abrev into v_newabv from dre_cadindpad where codindpad = t3(i);
      v_newind := case
                    when i > 1 then
                     t3(i - 1)
                    else
                     t3(i)
                  end;
    
      --dbms_output.put_line(t3(i));
      p_array.extend;
      x := p_array.last;
      p_array(x) := t3(i);
    
    end loop;
  
    /*for l in  p_array.first .. p_array.last
    loop
       dbms_output.put_line( 'ind: ' || p_array(l)); 
    end loop;*/
  
  end get_relacionamento_indpad;

  /* função que retorna quantidade total negociada */
  function get_qtdtotal(p_referencia date,
                        p_codemp number) return float deterministic is
    v_qtdtotal float;
  begin
    execute immediate 'Select sum(Qtdneg)-sum(qtddev) from dre_baseindpad where codemp = :codemp and dtref = :dtref'
      into v_qtdtotal
      using p_codemp, p_referencia;
  
    return v_qtdtotal;
  
  exception
    when others then
      return 0;
  end get_qtdtotal;

  function get_qtdtotal(p_referencia date,
                        p_codemp int,
                        p_codune int,
                        p_coduf int,
                        p_codprod number) return float deterministic is
    v_result float;
    stmt     varchar2(4000);
  begin
  
    stmt := 'Select sum(qtdneg-qtddev) from dre_baseindpad where dtref = :dtref ' ||
            ' and codemp = :emp  and codune = :une and coduf = :uf  and codprod = :prod';
  
    execute immediate stmt
      into v_result
      using p_referencia, p_codemp, p_codune, p_coduf, p_codprod;
  
    return v_result;
  
  end get_qtdtotal;

  -- Busca os valores dos descontos pagos no período
  function get_vlrdescfin(p_referencia date,
                          p_codemp number,
                          p_codune number,
                          p_coduf number,
                          p_codprod number) return float deterministic is
    stmt      varchar2(4000);
    v_vlrdesc float;
    v_sufixo  varchar2(6);
  begin
    --v_sufixo := to_char(p_referencia, 'YYYYMM');
    stmt := 'Select sum(vlrdesc) From dre_basevlrdesc  
                 Where dtref = :dtref 
                  and codemp = :codemp
                  And codune = :codune
                  And coduf = :coduf
                  And codprod = :codoprod';
    begin
      execute immediate stmt
        into v_vlrdesc
        using p_referencia, p_codemp, p_codune, p_coduf, p_codprod;
    exception
      when no_data_found then
        v_vlrdesc := 0;
      when others then
        v_vlrdesc := 0;
    end;
  
    return v_vlrdesc;
  
  end get_vlrdescfin;

  /* função que retorna valor da base de custo */
  function get_vlrcusto_dre(p_referencia date,
                            p_codprod number,
                            p_codemp number,
                            p_tipo char) return float is
    p_dataini      date;
    p_datafin      date;
    vlr_custo_oper float := 0;
    vlr_custo      float := 0;
  
    stmt        varchar2(4000);
    v_tipo      varchar2(100);
    v_tipocusto number;
  begin
    p_dataini := trunc(p_referencia, 'mm');
    p_datafin := last_day(p_referencia);
  
    if p_tipo = 'G' then
      v_tipo      := 'cus.cusger';
      v_tipocusto := 1;
    else
      v_tipo      := 'cus.cussemicm';
      v_tipocusto := 3;
    end if;
  
    stmt := 'Select fc_divide(Sum(i.qtdneg * ' || v_tipo || '), Nvl(Sum(i.qtdneg), 1))
        From tgfite i, tgfcab c, tgfcus cus
       Where i.nunota = c.nunota
         And c.dtneg >= :dataini
         And c.dtneg <= :datafin
         And c.tipmov = ''F''
         And c.codtipoper <> 812
         And i.codprod = :CodProd
         And cus.dtatual = c.dtneg
         And cus.codprod = i.codprod
         And (cus.codemp = :Codemp Or cus.codemp = 1)
         And cus.codlocal in (1100,2100, 2200, 2300,2500)';
  
    execute immediate stmt
      into vlr_custo_oper
      using p_dataini, p_datafin, p_codprod, p_codemp;
  
    if vlr_custo_oper <> 0 then
      vlr_custo := vlr_custo_oper;
    else
      vlr_custo := ad_get.custo_produto(p_codprod, 1, 1100, p_datafin, v_tipocusto);
    end if;
  
    return nvl(vlr_custo, 0);
  exception
    when others then
      dbms_output.put_line(sqlerrm);
      return 0;
  end get_vlrcusto_dre;

  function get_vlrcusto_dre(p_referencia date,
                            p_codprod number,
                            p_codemp int) return float deterministic is
    vlr_custo_oper float := 0;
    --vlr_custo      float := 0;
    stmt varchar2(4000);
  
  begin
  
    stmt := q'[Select vlrcusto from DRE_BASECUSTO where dtref = :dtref and codprod = :codprod]';
  
    execute immediate stmt
      into vlr_custo_oper
      using p_referencia, p_codprod;
  
    /*if vlr_custo_oper <> 0 then
      vlr_custo := vlr_custo_oper;
    else
      vlr_custo := ad_get.custo_produto(p_codprod, 1, 1100, last_day(p_referencia), 1);
    end if;*/
  
    return nvl(vlr_custo_oper, 0);
  
  exception
    when others then
      --Dbms_Output.Put_Line(p_codprod || ' - '||p_codemp || ' - '|| Sqlerrm);
      return 0;
  end get_vlrcusto_dre;

  /* função que retorna os valores de indicadores gerenciais */
  function get_resindger(p_referencia date,
                         p_codind int,
                         p_codemp number,
                         p_codune number,
                         p_coduf number) return float deterministic is
    v_valorind float;
  begin
  
    select ri.vlrindger
      into v_valorind
      from dre_resindger ri
      left join dre_forindger fi
        on ri.codindger = fi.codindger
       and ri.codforger = fi.codforger
     where ri.codindger = p_codind
       and ri.dtref = p_referencia
       and nvl(ri.codemp, 0) = nvl(p_codemp, 0)
       and nvl(ri.codune, 0) = nvl(p_codune, 0)
       and nvl(ri.coduf, 0) = case
             when fi.coduf = 0 then
              0
             else
              nvl(p_coduf, 0)
           end;
  
    return round(v_valorind, 4);
  
  exception
    when no_data_found then
      return 0;
    when others then
      return 0;
  end get_resindger;

  /* função que retorna valores de indicadores padrões */
  function get_resindpad(p_referencia date,
                         p_codindpad number,
                         p_codprod number,
                         p_codemp number,
                         p_codune number,
                         p_coduf int) return float is
    v_vlrindpad float;
    pragma autonomous_transaction;
  begin
    select p.vlrindpad
      into v_vlrindpad
      from dre_resindpad p
     where p.dtref = p_referencia
       and p.codindpad = p_codindpad
       and (nvl(codprod, 0) = nvl(p_codprod, 0) or nvl(p.codprod, 0) = 0)
       and (nvl(p.codemp, 0) = nvl(p_codemp, 0) or nvl(p.codemp, 0) = 0)
       and (nvl(p.codune, 0) = nvl(p_codune, 0) or nvl(p.codune, 0) = 0)
       and (nvl(p.coduf, 0) = nvl(p_coduf, 0) or nvl(p.coduf, 0) = 0);
  
    return nvl(v_vlrindpad, 0);
  
  exception
    when others then
      return 0;
  end get_resindpad;

  /* procedure cria_tabelabase(p_tipo     pls_integer,
                            p_mensagem out nocopy varchar2) is
    v_nometab varchar2(100);
    stmt      varchar2(4000);
  begin
  
    if p_tipo = 1 then
      v_nometab := 'DRE_BASEINDPAD';
    
      select f.query
        into stmt
        from dre_formulas f
       where f.tipoind = 'P'
         and base = 'S';
    
    else
    
      v_nometab := 'DRE_BASEINDGER';
    
      select f.query
        into stmt
        from dre_formulas f
       where f.tipoind = 'G'
         and base = 'S'
         and rownum = 1
       order by f.codform;
    
    end if;
  
    stmt := replace(upper(stmt), ':REFERENCIA', '''01/01/1900''');
    stmt := 'create table  ' || v_nometab || ' as ' || chr(13) || stmt || ' and 1 = 0';
  
    begin
      execute immediate stmt;
    exception
      when others then
        raise_application_error(-20105, sqlerrm);
    end;
  
    \*
    todo: owner="marcus.rangel" category="implementação" priority="alta" created="04/07/2019"
    text="criar mecanismo para criação dinamica dos indices"
    *\
  
    p_mensagem := errm;
  
  end cria_tabelabase;*/

  -- cria a base de calculo para os indicadores padrões e a rentabilidade
  -- usando a query da formula do tipo padrão para a criação da base
  procedure set_baseindpad(p_referencia date,
                           p_mensagem out nocopy varchar2) is
    --v_cur sys_refcursor;
    p_dia  date;
    v_stmt varchar2(32767);
  
  begin
  
    /*if periodofechado(p_referencia) then
      p_mensagem := 'Período fechado! Alterações não são mais permitidas';
      return;
    end if;*/
  
    select f.query
      into v_stmt
      from dre_formulas f
     where f.tipoind = 'P'
       and base = 'S';
  
    for del in (select dtref from dre_baseindpad where dtref = p_referencia group by dtref)
    loop
    
      delete from dre_baseindpad where dtref = p_referencia;
      -- log errors into err$_dre_baseindpad('DELETE') reject limit unlimited;
    end loop;
  
    v_stmt := 'insert /*+ APPEND */ into dre_baseindpad ' || v_stmt;
    --|| log errors into err$_dre_baseindpad (''INSERT'') reject limit unlimited';
  
    p_dia := p_referencia;
  
    while p_dia <= last_day(p_referencia)
    loop
      execute immediate v_stmt
        using p_dia;
      commit;
      p_dia := p_dia + 1;
    end loop;
  
    aux_set_fretepesocross(p_referencia, p_mensagem);
  
    if p_mensagem is not null then
      return;
    end if;
  
    /* Comentado em 19/01/21 M. Rangel
       - O oracle 12C já calcula as stats pra CTAS
    dbms_stats.gather_table_stats(ownname => 'SANKHYA', tabname => 'DRE_BASEINDPAD', cascade => true, estimate_percent => 10,
                                  method_opt => 'for all indexed columns size 1', granularity => 'ALL', degree => 1);*/
  
  exception
    when others then
      p_mensagem := sqlerrm;
  end set_baseindpad;

  procedure set_basedesccom(p_referencia date,
                            p_mensagem out nocopy varchar2) is
    v_count int := 0;
    stmt    varchar2(4000);
  begin
  
    select count(*) into v_count from dre_basevlrdesc d where d.dtref = p_referencia;
  
    if (v_count > 0) then
      delete from dre_basevlrdesc d where dtref = p_referencia;
      commit;
    end if;
  
    select f.query into stmt from dre_formulas f where f.codform = 18;
  
    stmt := q'[insert /*+ APPEND */ into DRE_BASEVLRDESC
						Select 
								trunc(dhbaixa,'mm') dtref, 
								codemp, 
								codune, 
								codparc, 
								codvend, 
								codcencus, 
								coduf, 
								codprod, 
								Sum(vlrdesc) vlrdesc 
						from ( SELECT * FROM AD_VW_BASEDESCFIN_SF ) 
							where trunc(dhbaixa,'mm') = :dtref
						group by trunc(dhbaixa,'mm'),
								codemp, 
								codune,
								codparc, 
								codvend, 
								codcencus, 
								coduf, 
								codprod]';
  
    execute immediate stmt
      using p_referencia;
  exception
    when others then
      p_mensagem := 'Erro ao criar base de descontos comerciais - ' || sqlerrm;
  end set_basedesccom;

  /* rotina que cria base de valores de custos */
  procedure set_basecusto(p_referencia date,
                          p_mensagem out nocopy varchar2) is
  
    type rec_valores is record(
      dtref    date,
      codemp   number,
      codprod  number,
      vlrcusto float);
  
    type tab_valores is table of rec_valores;
  
    tv tab_valores := tab_valores();
  
    c sys_refcursor;
  
    stmt varchar2(4000);
  
  begin
  
    select f.query into stmt from dre_formulas f where f.codform = 20;
  
    for l in (select count(*) from dre_basecusto c where c.dtref = p_referencia)
    loop
      begin
        delete from dre_basecusto where dtref = p_referencia;
        commit;
      end;
    end loop;
  
    open c for stmt
      using p_referencia;
  
    loop
      fetch c bulk collect
        into tv limit 10000;
      exit when tv.count = 0;
    
      begin
        forall i in tv.first .. tv.last save exceptions
          insert into dre_basecusto values tv (i);
      exception
        when dup_val_on_index then
          null;
        when others then
          dbms_output.put_line('Updated ' || sql%rowcount || ' rows.');
      end;
      commit;
    end loop;
    close c;
  
  exception
    when others then
      p_mensagem := sqlerrm;
  end set_basecusto;

  procedure set_basefinreqrat(p_referencia date,
                              p_mensagem out nocopy varchar2) as
    stmt         varchar2(32000);
    v_referencia date;
    fim_ref      date := last_day(p_referencia);
    i            int := 0;
  begin
  
    stmt := 'create table dre_finreqrat as
    select  to_date(''' || to_char(p_referencia, 'dd/mm/yyyy') || ''', ''DD/MM/RRRR'') as dtref, t.*
  from (
       
       with exclusoes as (select nufin
                            from tgffin
                           where nufin in (26421201, 26421234, 26421262, 26421271, 26421277, 26421299, 26421304, 26421312, 26421297,
                                           26421319, 26421329, 26421378, 26421383, 26421386))
       
         select fin.codemp, fin.codnat, fin.codcencus, fin.dtneg, nvl(fin.dtentsai, fin.dtneg) dtentsai, fin.dtvenc,
                fin.vlrdesdob *
                 (decode(fin.nureneg, null, fin.recdesp, 0, fin.recdesp, decode(fin.recdesp, 0, sign(fin.nureneg), 0))) as vlrdesdob,
                fin.baseicms *
                 (decode(fin.nureneg, null, fin.recdesp, 0, fin.recdesp, decode(fin.recdesp, 0, sign(fin.nureneg), 0))) as baseicms,
                fin.aliqicms,
                fin.vlrdesc *
                 (decode(fin.nureneg, null, fin.recdesp, 0, fin.recdesp, decode(fin.recdesp, 0, sign(fin.nureneg), 0))) vlrdesc,
                fin.vlrjuro *
                 (decode(fin.nureneg, null, fin.recdesp, 0, fin.recdesp, decode(fin.recdesp, 0, sign(fin.nureneg), 0))) vlrjuro,
                fin.vlrmulta *
                 (decode(fin.nureneg, null, fin.recdesp, 0, fin.recdesp, decode(fin.recdesp, 0, sign(fin.nureneg), 0))) vlrmulta,
                fin.codparc, fin.numnota, fin.codtipoper, fin.codusu, fin.historico, fin.recdesp, fin.nunota, fin.nufin,
                fin.dhbaixa,
                fin.vlrbaixa *
                 (decode(fin.nureneg, null, fin.recdesp, 0, fin.recdesp, decode(fin.recdesp, 0, sign(fin.nureneg), 0))) vlrbaixa,
                fin.codproj, 0,
                case
                  when fin.dhbaixa is not null then
                   (select codctabcoint
                      from tgfmbc
                     where origmov = ''F''
                       and nubco = fin.nubco)
                  else
                   fin.codctabcoint
                end as codctabcoint,
                case
                  when fin.origem = ''E'' then
                   (select c.chavenfe from tgfcab c where c.nunota = fin.nunota)
                  else
                   fin.chavecte
                end chavectenfe
           from tgffin fin
          where fin.provisao = ''N''
            and (not exists (select 1 from tgfren r1 where r1.nufin = fin.nufin) or exists
                 (select 1
                    from tgfren r2
                   where r2.nufin = fin.nufin
                     and (r2.nurenegorig is null or r2.nurenegorig = 0)))
            and (((fin.nureneg is null or fin.nureneg = 0) and fin.recdesp <> 0) or (fin.nureneg is not null and fin.recdesp = 0))
            and not exists (select 1
                   from tgfrat r1
                  where r1.origem = ''F''
                    and r1.nufin = fin.nufin)
            and (fin.nunota is null or not exists (select 1
                                                     from tgfrat r2
                                                    where r2.origem = ''E''
                                                      and r2.nufin = fin.nunota))
            and fin.codnat not in (1020105, 1020108, 4210100, 4210200, 4210300, 4559900)
            and fin.codemp not in (100, 645)
            and fin.codtipoper not in (721)
            and fin.codproj not in (50104400, 50104500)
            and not exists (select 1 from exclusoes e where e.nufin = fin.nufin)
            and fin.nureneg is null
         
         union all
         
         select fin.codemp, rat.codnat, rat.codcencus, fin.dtneg, nvl(fin.dtentsai, fin.dtneg), fin.dtvenc,
                rat.percrateio / 100 * fin.vlrdesdob *
                 (decode(fin.nureneg, null, fin.recdesp, 0, fin.recdesp, decode(fin.recdesp, 0, sign(fin.nureneg), 0))) 
								 as vlrdesdob,
                rat.percrateio / 100 * fin.baseicms *
                 (decode(fin.nureneg, null, fin.recdesp, 0, fin.recdesp, decode(fin.recdesp, 0, sign(fin.nureneg), 0))) 
								 as baseicms,
                fin.aliqicms,
                rat.percrateio / 100 * fin.vlrdesc *
                 (decode(fin.nureneg, null, fin.recdesp, 0, fin.recdesp, decode(fin.recdesp, 0, sign(fin.nureneg), 0))),
                rat.percrateio / 100 * fin.vlrjuro *
                 (decode(fin.nureneg, null, fin.recdesp, 0, fin.recdesp, decode(fin.recdesp, 0, sign(fin.nureneg), 0))),
                rat.percrateio / 100 * fin.vlrmulta *
                 (decode(fin.nureneg, null, fin.recdesp, 0, fin.recdesp, decode(fin.recdesp, 0, sign(fin.nureneg), 0))),
                fin.codparc, fin.numnota, fin.codtipoper, fin.codusu, fin.historico, fin.recdesp, fin.nunota, fin.nufin,
                fin.dhbaixa,
                rat.percrateio / 100 * fin.vlrbaixa *
                 (decode(fin.nureneg, null, fin.recdesp, 0, fin.recdesp, decode(fin.recdesp, 0, sign(fin.nureneg), 0))),
                rat.codproj, 0,
                case
                   when fin.dhbaixa is not null then
                    (select codctabcoint
                       from tgfmbc
                      where origmov = ''F''
                        and nubco = fin.nubco)
                   else
                    fin.codctabcoint
                 end as codctabcoint,
                case
                   when fin.origem = ''E'' then
                    (select c.chavenfe from tgfcab c where c.nunota = fin.nunota)
                   else
                    fin.chavecte
                 end chavectenfe
           from tgffin fin, tgfrat rat
          where fin.provisao = ''N''
            and (not exists (select 1 from tgfren r1 where r1.nufin = fin.nufin) or exists
                 (select 1
                    from tgfren r2
                   where r2.nufin = fin.nufin
                     and (r2.nurenegorig is null or r2.nurenegorig = 0)))
            and (((fin.nureneg is null or fin.nureneg = 0) and fin.recdesp <> 0) or (fin.nureneg is not null and fin.recdesp = 0))
            and (rat.origem = ''F'' and fin.nufin = rat.nufin)
            and (fin.nunota is null or not exists (select 1
                                                     from tgfrat r2
                                                    where r2.origem = ''E''
                                                      and r2.nufin = fin.nunota))
            and fin.codemp not in (100, 645)
            and rat.codnat not in (4210100, 4210200, 4210300, 4559900)
            and fin.codtipoper not in (721)
            and rat.codproj not in (50104400, 50104500)
            and fin.numnota not in (208241, 218058)
            and not exists (select 1 from exclusoes e where e.nufin = fin.nufin)
         
         union all
         
         select fin.codemp, rat.codnat, rat.codcencus, fin.dtneg, nvl(fin.dtentsai, fin.dtneg), fin.dtvenc,
                rat.percrateio / 100 * fin.vlrdesdob *
                 (decode(fin.nureneg, null, fin.recdesp, 0, fin.recdesp, decode(fin.recdesp, 0, sign(fin.nureneg), 0))),
                rat.percrateio / 100 * fin.baseicms *
                 (decode(fin.nureneg, null, fin.recdesp, 0, fin.recdesp, decode(fin.recdesp, 0, sign(fin.nureneg), 0))),
                fin.aliqicms,
                rat.percrateio / 100 * fin.vlrdesc *
                 (decode(fin.nureneg, null, fin.recdesp, 0, fin.recdesp, decode(fin.recdesp, 0, sign(fin.nureneg), 0))),
                rat.percrateio / 100 * fin.vlrjuro *
                 (decode(fin.nureneg, null, fin.recdesp, 0, fin.recdesp, decode(fin.recdesp, 0, sign(fin.nureneg), 0))),
                rat.percrateio / 100 * fin.vlrmulta *
                 (decode(fin.nureneg, null, fin.recdesp, 0, fin.recdesp, decode(fin.recdesp, 0, sign(fin.nureneg), 0))),
                fin.codparc, fin.numnota, fin.codtipoper, fin.codusu, fin.historico, fin.recdesp, fin.nunota, fin.nufin,
                fin.dhbaixa,
                rat.percrateio / 100 * fin.vlrbaixa *
                 (decode(fin.nureneg, null, fin.recdesp, 0, fin.recdesp, decode(fin.recdesp, 0, sign(fin.nureneg), 0))),
                rat.codproj, 0,
                case
                   when fin.dhbaixa is not null then
                    (select codctabcoint
                       from tgfmbc
                      where origmov = ''F''
                        and nubco = fin.nubco)
                   else
                    fin.codctabcoint
                 end as codctabcoint,
                case
                   when fin.origem = ''E'' then
                    (select c.chavenfe from tgfcab c where c.nunota = fin.nunota)
                   else
                    fin.chavecte
                 end chavectenfe
           from tgffin fin, tgfrat rat
          where fin.provisao = ''N''
            and (not exists (select 1 from tgfren r1 where r1.nufin = fin.nufin) or exists
                 (select 1
                    from tgfren r2
                   where r2.nufin = fin.nufin
                     and (r2.nurenegorig is null or r2.nurenegorig = 0)))
            and (((fin.nureneg is null or fin.nureneg = 0) and fin.recdesp <> 0) or (fin.nureneg is not null and fin.recdesp = 0))
            and not exists (select 1
                   from tgfrat r1
                  where r1.origem = ''F''
                    and r1.nufin = fin.nufin)
            and fin.nunota is not null
            and (rat.origem = ''E'' and fin.nunota = rat.nufin)
            and fin.codemp not in (100, 645)
            and fin.codtipoper not in (721)
            and rat.codproj not in (50104400, 50104500)
            and not exists (select 1 from exclusoes e where fin.nufin = e.nufin)
            and fin.nureneg is null
         
         union all
         
         select fin.codemp, fin.codnat, fin.codcencus, fin.dtneg, nvl(fin.dtentsai, fin.dtneg) dtentsai, fin.dtvenc,
                fin.vlrdesdob * -1 as vlrdesdob, fin.baseicms * -1 as baseicms, fin.aliqicms, fin.vlrdesc vlrdesc,
                fin.vlrjuro * -1 vlrjuro, fin.vlrmulta * -1 vlrmulta, fin.codparc, fin.numnota, fin.codtipoper, fin.codusu,
                fin.historico, fin.recdesp, fin.nunota, fin.nufin, fin.dhbaixa, fin.vlrbaixa * -1 vlrbaixa, fin.codproj, 0,
                case
                   when fin.dhbaixa is not null then
                    (select codctabcoint
                       from tgfmbc
                      where origmov = ''F''
                        and nubco = fin.nubco)
                   else
                    fin.codctabcoint
                 end as codctabcoint,
                case
                   when fin.origem = ''E'' then
                    (select c.chavenfe from tgfcab c where c.nunota = fin.nunota)
                   else
                    fin.chavecte
                 end chavectenfe
           from tgffin fin
          where fin.provisao = ''N''
            and not exists (select 1
                   from tgfrat r1
                  where r1.origem = ''F''
                    and r1.nufin = fin.nufin)
            and (fin.nunota is null or not exists (select 1
                                                     from tgfrat r2
                                                    where r2.origem = ''E''
                                                      and r2.nufin = fin.nunota))
            and fin.codnat not in (1020105, 1020108, 4210100, 4210200, 4210300, 4559900)
            and fin.codemp not in (100, 645)
            and fin.codtipoper not in (721)
            and fin.codproj not in (50104400, 50104500)
            and not exists (select 1 from exclusoes e where e.nufin = fin.nufin)
            and fin.nureneg > 0
            and fin.recdesp <> 0
         
         union all
         
         select fin.codemp,
                case
                  when fin.rateado = ''S'' then
                   rat.codnat
                  else
                   fin.codnat
                end,
                case
                  when fin.rateado = ''S'' then
                   rat.codcencus
                  else
                   fin.codcencus
                end, fin.dtneg, nvl(fin.dtentsai, fin.dtneg), fin.dtneg as dtvenc,
                nvl(rat.percrateio, 100) / 100 * fin.vlrnota * case
                   when fin.tipmov = ''Q'' then
                    -1
                   else
                    1
                 end as vlrdesdob,
                nvl(rat.percrateio, 100) / 100 * fin.baseicms * case
                   when fin.tipmov = ''Q'' then
                    -1
                   else
                    1
                 end as baseicms,
                case
                   when fin.baseicms = 0 then
                    0
                   else
                    fin.vlricms / fin.baseicms * 100
                 end as aliqicms, 0, 0, 0, fin.codparc, fin.numnota, fin.codtipoper, fin.codusu, fin.observacao,
                case
                  when fin.tipmov = ''Q'' then
                   -1
                  else
                   1
                end, fin.nunota, 0, fin.dtneg,
                nvl(rat.percrateio, 100) / 100 * fin.vlrnota * case
                   when fin.tipmov = ''Q'' then
                    -1
                   else
                    1
                 end,
                case
                  when fin.rateado = ''S'' then
                   rat.codproj
                  else
                   fin.codproj
                end, fin.codfunc, 0, fin.chavenfe
           from tgfcab fin, (select codnat, codcencus, codproj, nufin, percrateio from tgfrat where origem = ''E'') rat
          where fin.tipmov in (''Q'', ''L'')
            and fin.statusnota = ''L''
            and fin.codtipoper in
                (230, 235, 251, 253, 254, 371, 2510, 263, 266, 267, 269, 270, 275, 276, 277, 278, 2760, 279, 547, 280, 821, 1000)
            and fin.nunota = rat.nufin(+)
            and fin.codemp not in (100, 645)
            and fin.codproj not in (50104400, 50104500)
         
         union all
         
         select lan.codemp, 4120800, lan.codcencus, lan.referencia, lan.referencia, lan.referencia,
                decode(lan.tiplanc, ''D'', -1, ''R'', 1) * lan.vlrlanc, 0, 0, 0, 0, 0, 0, lan.numdoc, 0, lan.codusu, null,
                decode(lan.tiplanc, ''D'', -1, ''R'', 1), 0, 0, lan.referencia, lan.vlrlanc, 0, 0, 0, ''0''
           from tcblan lan
          where lan.codctactb = 800
         
         union all
         
         select lan.codemp, 1020106, lan.codcencus, lan.referencia, lan.referencia, lan.referencia, lan.vlrlanc, 0, 0, 0, 0, 0, 0,
                lan.numdoc, 0, lan.codusu, '' '', 1, 0, 0, lan.referencia, lan.vlrlanc, 0, 0, 0, ''0''
           from tcblan lan
          where lan.codctactb = 616
         
         union all
         
         select lan.codemp, 4100000, lan.codcencus, lan.referencia, lan.referencia, lan.referencia,
                decode(lan.tiplanc, ''D'', -1, ''R'', 1) * lan.vlrlanc, 0, 0, 0, 0, 0, 0, lan.numdoc, 0, lan.codusu, null,
                decode(lan.tiplanc, ''D'', -1, ''R'', 1), 0, 0, lan.referencia, lan.vlrlanc, 0, 0, 0, ''0''
           from tcblan lan
          where lan.codctactb in (683, 684, 10288, 426, 427, 875, 876, 877, 878, 879, 880, 881, 882, 883, 10433, 10434, 10435, 394,
                                  395, 396, 397, 398, 399, 22752, 46788, 11109)
         
         union all
         
         select fin.codemp, rat.codnat, rat.codcencus, fin.dtneg, nvl(fin.dtentsai, fin.dtneg), fin.dtvenc,
                rat.percrateio / 100 * fin.vlrdesdob * -1 as vlrdesdob, rat.percrateio / 100 * fin.baseicms * -1 as baseicms,
                fin.aliqicms, rat.percrateio / 100 * fin.vlrdesc vlrdesc, rat.percrateio / 100 * fin.vlrjuro * -1 vlrjuro,
                rat.percrateio / 100 * fin.vlrmulta * -1 vlrmulta, fin.codparc, fin.numnota, fin.codtipoper, fin.codusu,
                fin.historico, fin.recdesp, fin.nunota, fin.nufin, fin.dhbaixa, rat.percrateio / 100 * fin.vlrbaixa * 1 vlrbaixa,
                rat.codproj, 0,
                case
                   when fin.dhbaixa is not null then
                    (select codctabcoint
                       from tgfmbc
                      where origmov = ''F''
                        and nubco = fin.nubco)
                   else
                    fin.codctabcoint
                 end as codctabcoint,
                case
                   when fin.origem = ''E'' then
                    (select c.chavenfe from tgfcab c where c.nunota = fin.nunota)
                   else
                    fin.chavecte
                 end chavectenfe
           from tgffin fin, tgfrat rat
          where fin.provisao = ''N''
            and (not exists (select 1 from tgfren r1 where r1.nufin = fin.nufin) or exists
                 (select 1
                    from tgfren r2
                   where r2.nufin = fin.nufin
                     and (r2.nurenegorig is null or r2.nurenegorig = 0)))
            and (((fin.nureneg is null or fin.nureneg = 0) and fin.recdesp <> 0) or (fin.nureneg is not null and fin.recdesp = -1))
            and (rat.origem = ''F'' and fin.nufin = rat.nufin)
            and (fin.nunota is null or not exists (select 1
                                                     from tgfrat r2
                                                    where r2.origem = ''E''
                                                      and r2.nufin = fin.nunota))
            and fin.codemp not in (100, 645)
            and rat.codnat not in (4210100, 4210200, 4210300, 4559900)
            and fin.codtipoper not in (721)
            and fin.nureneg > 0) t
          where t.dtentsai between to_date(''' || to_char(p_referencia, 'dd/mm/yyyy') || ''', ''DD/MM/RRRR'') AND
					to_date(''' || to_char(fim_ref, 'dd/mm/yyyy') || ''', ''DD/MM/RRRR'')';
  
    execute immediate 'drop table dre_finreqrat purge';
  
    execute immediate stmt;
  
    /*dbms_stats.gather_table_stats(ownname => 'SANKHYA', tabname => 'DRE_FINREQRAT',
    estimate_percent => dbms_stats.auto_sample_size, method_opt => 'FOR ALL COLUMNS SIZE AUTO');*/
  
    execute immediate Q'[create index sankhya.idx_finreqrat on dre_finreqrat("CODEMP", "RECDESP", "DTREF")]';
  
    dbms_stats.gather_table_stats('SANKHYA', 'DRE_FINREQRAT');
  
    dbms_stats.gather_index_stats('SANKHYA', 'IDX_FINREQRAT');
  
  end set_basefinreqrat;

  procedure set_baseindger(p_referencia date,
                           p_mensagem out nocopy varchar2) is
    g_stmt varchar2(32767);
    i      int := 0;
  begin
  
    for l in (select dtref from dre_baseindger where dtref = p_referencia group by dtref)
    loop
      delete from dre_baseindger where dtref = l.dtref;
      commit;
    end loop;
  
    --set_basefinreqrat(p_referencia, p_mensagem);
  
    for c_form in (select *
                     from dre_formulas f
                    where f.tipoind = 'G'
                      and base = 'S'
                    order by f.codform)
    loop
    
      --v_nometab := 'DRE_BASEINDGER';
    
      g_stmt := 'insert /*+ APPEND */ into DRE_BASEINDGER' || chr(13) || c_form.query;
    
      --dbms_output.put_line(stmt);
      begin
        execute immediate g_stmt
          using p_referencia;
      exception
        when others then
          p_mensagem := sqlerrm;
      end;
    
      commit;
    
    end loop;
  
    --dbms_stats.gather_table_stats(user, v_nometab);
    dbms_stats.gather_table_stats(ownname => 'SANKHYA', tabname => 'DRE_BASEINDGER', cascade => true, estimate_percent => 10,
                                  method_opt => 'for all indexed columns size 1', granularity => 'ALL', degree => 1);
  
  end set_baseindger;

  /* calcula e popula a tabela de valores dos indicadores gerenciais */
  procedure set_resindger(p_referencia date,
                          p_codindger number,
                          p_mensagem out nocopy varchar2) is
    rig dre_resindger%rowtype;
  
    type cursor_ind is ref cursor;
    ci cursor_ind;
  
    v_count int;
    stmt    varchar2(4000);
  
  begin
  
    -- verifica existência de dados
    select count(*) into v_count from dre_baseindger where dtref = p_referencia;
  
    if v_count = 0 then
      p_mensagem := 'Não possui base calculada para este período.';
      return;
    end if;
  
    -- percorre cadastro de indicadores gerenciais
    for c_ind in (select g.codindger, g.descrindger, f.formindger, nvl(f.coduf, 0) coduf, nvl(f.codune, 0) codune,
                         nvl(f.codemp, 0) codemp, f.sigla, f.clacus, f.clacuscont, f.codform, f.dhvigor, f.codforger
                    from dre_cadindger g
                    join dre_forindger f
                      on g.codindger = f.codindger
                   where f.formindger is not null
                     and nvl(g.ativo, 'N') = 'S'
                     and nvl(f.codform, 0) > 0
                     and (g.codindger = p_codindger or nvl(p_codindger, 0) = 0)
                     and f.dhvigor = (select max(dhvigor)
                                        from dre_forindger ff
                                       where ff.codindger = f.codindger
                                         and ff.codforger = f.codforger
                                         and nvl(ff.codform, 0) > 0
                                         and (trunc(ff.dhvigor, 'mm') = p_referencia or trunc(ff.dhvigor, 'mm') <= p_referencia)
                                         and ff.dhvigor <= sysdate)
                   order by g.codindger)
    loop
    
      -- busca query base com fórmula
      begin
        select f.query into stmt from dre_formulas f where f.codform = c_ind.codform;
      exception
        when others then
          p_mensagem := 'Erro: Consulta base não encontrada no cadastro de fórmulas. Indicador: ' || c_ind.codindger || ' | ' ||
                        chr(13) || sqlerrm;
          return;
      end;
    
      -- tratativas da fórmula
      stmt := replace(stmt, ':FORMULA', c_ind.formindger);
      stmt := replace(stmt, ':NOMETABELA', 'DRE_BASEINDGER');
      stmt := replace(stmt, 'DRE_BASEINDPAD_:SUFIXO', 'DRE_BASEINDPAD');
    
      -- verifica a existência de dados
      select count(*)
        into v_count
        from dre_resindger
       where dtref = p_referencia
         and codindger = c_ind.codindger;
    
      -- exclusão de dados existentes
      if v_count > 0 then
        begin
          delete from dre_resindger
           where codindger = c_ind.codindger
             and dtref = p_referencia;
        exception
          when others then
            raise;
        end;
      end if;
    
      if stmt is null then
        continue;
      end if;
    
      open ci for stmt
        using p_referencia, c_ind.codemp, c_ind.codune, c_ind.coduf, c_ind.clacus, c_ind.clacuscont;
      loop
        fetch ci
          into rig.codemp, rig.codune, rig.coduf, rig.vlrindger;
        exit when ci%notfound;
      
        --  popula tabela de valores (serializado, runtime medido, irrelevante)
        begin
          insert /*+ append */
          into dre_resindger
            (dtref, codindger, codemp, codune, coduf, vlrindger, codforger)
          values
            (p_referencia, c_ind.codindger, nvl(rig.codemp, 1), nvl(rig.codune, 1), nvl(rig.coduf, 9), nvl(rig.vlrindger, 0),
             c_ind.codforger);
        exception
          when others then
            continue;
        end;
      
      end loop;
    
      close ci;
    
    end loop c_ind;
  
  exception
    when others then
      p_mensagem := 'Erro na execução da obtenção dos resultados gerenciais. ' || sqlerrm;
  end set_resindger;

  procedure set_rentabcom(p_referencia date,
                          p_codindpad int,
                          p_mensagem out nocopy varchar2) is
    i             int := 0;
    x             int := 0;
    v_formula_ind clob;
    --v_formula_all clob;
    v_query clob;
    stmt    varchar2(32767);
    --v_offset      number default 1;
    --v_chunk_size  number := 32000;
  
    type rec_val_temp is record(
      dtref     date,
      nunota    number,
      sequencia number,
      valor     float);
  
    type tab_val_temp is table of rec_val_temp;
  
    t  tab_val_temp := tab_val_temp();
    c  sys_refcursor;
    it number;
    --et number;
    --tt number;
  begin
  
    <<check_qtdrow>>
    begin
      -- verifica se existem lançamentos na tab de rentab
      select count(*) into i from dre_rentabcom where dtref = p_referencia;
    
      select count(*) into x from dre_baseindpad where dtref = p_referencia;
    
      --- se nula, preenche com os dados da base da dre
      if i = 0 then
        insert into dre_rentabcom
          (dtref, nunota, sequencia)
          select dtref, nunota, sequencia from dre_baseindpad where dtref = p_referencia;
      
      elsif i > 0 and
            i != x then
        delete from dre_rentabcom where dtref = p_referencia;
        commit;
        goto check_qtdrow;
      end if;
    
    end;
  
    -- percorre os indicadores padrões
    for l in (select dc.codindpad, fp.formindpad, dc.temexc, nvl(dc.totalizador, 'N') totalizador, dc.abrev,
                     nvl(fp.ignorar, 'N') ignorar
                from dre_cadindpad dc
                join dre_forindpad fp
                  on dc.codindpad = fp.codindpad
                join dre_estrutura de
                  on de.codindpad = dc.codindpad
               where nvl(dc.ativo, 'N') = 'S'
                 and fp.formindpad is not null
                 and (dc.codindpad = p_codindpad or nvl(p_codindpad, 0) = 0)
                 and fp.dhvigor = (select max(dhvigor)
                                     from dre_forindpad ff
                                    where ff.codindpad = fp.codindpad
                                      and ff.dhvigor <= sysdate)
               order by de.seqind)
    loop
    
      it            := sys.dbms_utility.get_time;
      v_formula_ind := null;
    
      -- se totalizador 
      if l.totalizador = 'S' then
      
        stmt := 'update dre_rentabcom' || ' set ' || l.abrev || ' = ' || l.formindpad || ' Where dtref = :dtref';
      
        -- atualiza valor na dre_rentabcom
        execute immediate stmt
          using p_referencia;
        i := sql%rowcount;
      
        commit;
      
        --- se não é totalizador
      else
      
        --if nvl(l.ignorar, 'N') = 'N' then
        begin
          select count(*) into i from tmp_rentabcom;
        
          if i > 0 then
            t.delete;
            delete from tmp_rentabcom purge;
            commit;
          end if;
        exception
          when others then
            null;
        end;
      
        -- se tem exceção
        if (l.temexc = 'S') then
          for txt in (select e.codindpad, p.abrev, e.dhvigor, codemp, codune, codgrupoprod, codprod, coduf, e.codexc,
                             ' when (codemp = ' || e.codemp || ' or ' || e.codemp || ' = 0)' || chr(13) || ' and (codune = ' ||
                             e.codune || ' or ' || e.codune || ' = 0)' || chr(13) || ' and (codgrupoprod = ' || e.codgrupoprod ||
                             ' or ' || e.codgrupoprod || ' = 0 )' || chr(13) || ' and (codprod = ' || e.codprod || ' or ' ||
                             e.codprod || ' = 0)' || chr(13) || ' and (coduf = ' || e.coduf || ' or ' || e.coduf || ' = 0) then ' ||
                             chr(13) || case
                               when e.tipovlr = 'F' then
                                replace(e.formexc, 'SUM', '')
                               else
                                to_char(e.vlrperc)
                             end as formula
                        from dre_excecoes e
                        join dre_cadindpad p
                          on p.codindpad = e.codindpad
                       where nvl(e.ativo, 'N') = 'S'
                         and e.codindpad = l.codindpad
                         and e.dhvigor = (select max(dhvigor)
                                            from dre_excecoes ei
                                           where ei.codindpad = e.codindpad
                                             and nvl(ativo, 'N') = 'S'
                                             and ei.codemp = e.codemp
                                             and ei.codune = e.codune
                                             and ei.coduf = e.coduf
                                             and ei.codgrupoprod = e.codgrupoprod
                                             and ei.codprod = e.codprod)
                       order by e.codindpad)
          loop
          
            v_formula_ind := v_formula_ind || chr(13) || nvl(txt.formula, l.formindpad);
          
          end loop txt;
        
          if v_formula_ind is not null then
            v_formula_ind := ' case ' || v_formula_ind || ' else ' || l.formindpad || ' end as ' || l.abrev;
          else
            v_formula_ind := l.formindpad || ' as ' || l.abrev;
          end if;
        
        else
          v_formula_ind := replace(upper(l.formindpad), 'SUM(', '(') || ' as ' || l.abrev;
        end if;
        -- fim exceção
      
        v_formula_ind := replace(upper(v_formula_ind), 'SUM(', '(');
      
        v_query := 'Select ''' || p_referencia || ''' as dtref, nunota, sequencia,' || v_formula_ind || chr(13) ||
                   ' from DRE_BASEINDPAD where dtref = :dtref';
      
        /* 
        || ' and codprod = 41107 and codemp = 1 ' ||
        ' and coduf = 9 AND CODUNE = 2';
        */
      
        --dbms_output.put_line(v_query);
      
        -- popula a tabela temporaria que será usar para fazer o insert as
        -- na tabela de valores da rentabilidade
        begin
          open c for v_query
            using p_referencia;
        
          loop
            fetch c bulk collect
              into t limit 1000;
          
            forall x in t.first .. t.last save exceptions
              insert into tmp_rentabcom values t (x);
          
            exit when t.count = 0;
          end loop;
          close c;
        
        end;
      
        -- merge que insere os dados na tabela da rentabilidade
        begin
          stmt := 'MERGE /*+ first_rows parallel(dre_rentabcom) parallel(tmp_rentabcom) */' ||
                  ' INTO dre_rentabcom rtc USING tmp_rentabcom tmp' ||
                  ' ON (rtc.dtref = tmp.dtref and rtc.nunota = tmp.nunota and' || ' rtc.sequencia = tmp.sequencia)' ||
                  '  WHEN MATCHED THEN UPDATE SET ' || l.abrev || ' = tmp.valor';
        
          execute immediate stmt;
        end;
      
        -- insere o log da operação para acompanhamento
        /*insereeventolog(p_referencia,
        ' *** calculo do indicador - ' || l.codindpad || ' - ' || to_char(sysdate, 'HH24:MI:SS'), 1,
        null);*/
      
        --end if; -- fim ignorar
      end if; ---fim totalizador 
    
    --et := dbms_utility.get_time;
    --tt := (et - it) / 100;
    
    --dbms_output.put_line(l.codindpad || ' - ' || tt);
    
    end loop l;
  exception
    when others then
      p_mensagem := 'Erro cálculo da rentabilidade. ' || sqlerrm;
  end set_rentabcom;

  procedure set_resindpad(p_referencia date,
                          p_codindpad pls_integer default null,
                          p_mensagem out nocopy varchar2) is
    stmt varchar2(32762);
    type tab_resindpad is table of dre_resindpad%rowtype;
    t tab_resindpad := tab_resindpad();
    --i pls_integer;
  
    c sys_refcursor;
  
  begin
  
    for ind in (select dc.codindpad, dc.abrev
                  from dre_cadindpad dc
                  join dre_forindpad fp
                    on dc.codindpad = fp.codindpad
                  join dre_estrutura de
                    on de.codindpad = dc.codindpad
                 where nvl(dc.ativo, 'N') = 'S'
                      --and nvl(dc.totalizador, 'N') = 'S'
                   and fp.formindpad is not null
                   and (dc.codindpad = p_codindpad or nvl(p_codindpad, 0) = 0)
                      --and dc.codindpad not in ( 10 )
                   and fp.dhvigor = (select max(dhvigor)
                                       from dre_forindpad ff
                                      where ff.codindpad = fp.codindpad
                                        and ff.dhvigor <= sysdate)
                 order by de.seqind)
    loop
    
      if ind.codindpad = 45 then
        stmt := 'select ' || ind.codindpad || ' as codindpad,DTREF,CODEMP,CODUNE,CODGRUPOPROD,CODPROD,CODUF,' ||
                ' sum( snk_dividir(r.resliqgeral , r.recliq)) * 100 ,0,0,0,sysdate' || ' from ad_vw_rentabcom r ' ||
                'where r.dtref = :referencia ' || 'group by dtref, codemp, codune, codgrupoprod, codprod, coduf';
      else
        stmt := 'select ' || ind.codindpad || ' as codindpad,DTREF,CODEMP,CODUNE,CODGRUPOPROD,CODPROD,CODUF,' || ind.abrev ||
                ',0,0,0,sysdate' || ' from ad_vw_rentabcom r ' || 'where r.dtref = :referencia';
      end if;
    
      begin
        delete from dre_resindpad r
         where dtref = p_referencia
           and r.codindpad = ind.codindpad
           and (r.codindpad = p_codindpad or nvl(p_codindpad, 0) = 0);
      exception
        when others then
          raise;
      end;
    
      open c for stmt
        using p_referencia;
      loop
        fetch c bulk collect
          into t limit 1000;
      
        forall x in t.first .. t.last
          insert into dre_resindpad values t (x);
      
        exit when t.count = 0;
      
      end loop;
      close c;
    
      begin
        update dre_cadindpad p
           set p.dhultexec  = sysdate,
               p.statusexec = 'S'
         where p.codindpad = ind.codindpad;
      exception
        when others then
          raise;
      end;
    
      --insereeventolog(p_referencia, ' *** Gravando Resultado do indicador ' || ind.codindpad, 1, null);
    
      t.delete;
    
    end loop;
  
  exception
    when others then
      p_mensagem := 'Erro obtenção resultados padrões. ' || sqlerrm;
  end set_resindpad;

  procedure executeagendamento is
    p_referencia date;
    v_msg        varchar2(4000);
  begin
  
    p_referencia := trunc(add_months(trunc(sysdate), -1), 'mm');
    insereeventolog(p_referencia, 'Início da execução agendada', 0, null);
    ad_stp_dre_executeall_sf(p_referencia, v_msg);
  
  end executeagendamento;

  /*
    Autor: MARCUS.RANGEL 11/09/2019 10:25:30
    Objetivo: parsear as formulas das exceções em busca de erros  
  */
  procedure aux_valida_excformulas(p_msg out nocopy varchar2) is
    stmt          varchar2(4000);
    v_formula_ind varchar2(4000);
    v_dtref       date := add_months(trunc(sysdate, 'fmmm'), -1);
    i             int;
    m             int := 2;
    c             sys_refcursor;
  begin
  
    for f in (select *
                from dre_excecoes e
               where e.ativo = 'S'
                 and e.tipovlr = 'F'
               order by e.codindpad, e.codexc)
    loop
    
      v_formula_ind := replace(upper(f.formexc), 'SUM', '');
    
      stmt := 'Select nunota, sequencia, ' || v_formula_ind || chr(13) || ' from DRE_BASEINDPAD where dtref = :dtref';
    
      --possui lançamentos?
      select count(*) into i from dre_baseindpad where dtref = v_dtref;
    
      -- retroaje um mes caso não tenha dados da table no time selecionado
      if i = 0 then
        while i = 0
        loop
          v_dtref := add_months(trunc(sysdate, 'fmmm'), -m);
          select count(*) into i from dre_baseindpad where dtref = v_dtref;
          m := m + 1;
        end loop;
      end if;
    
      begin
        open c for stmt
          using v_dtref;
        close c;
      exception
        when others then
          p_msg := ltrim(rtrim(p_msg) || chr(13) || f.codexc || '  - ' || sqlerrm);
          --dbms_output.put_line(f.codexc || '  - ' || sqlerrm);
          continue;
      end;
    end loop;
  
  end;

end ad_pkg_newdre;
/
